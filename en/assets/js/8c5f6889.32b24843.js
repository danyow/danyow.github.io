"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7135],{35318:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return g}});var r=a(27378);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var m=r.createContext({}),s=function(e){var t=r.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=s(e.components);return r.createElement(m.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,m=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=s(a),g=n,h=d["".concat(m,".").concat(g)]||d[g]||u[g]||i;return a?r.createElement(h,l(l({ref:t},p),{},{components:a})):r.createElement(h,l({ref:t},p))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=d;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:n,l[1]=o;for(var s=2;s<i;s++)l[s]=a[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},88851:function(e,t,a){a.r(t),a.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return l},metadata:function(){return m},toc:function(){return p}});a(27378);var r=a(35318);function n(){return n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e},n.apply(this,arguments)}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}const l={id:"FrameTimingManager",slug:"/graphics/cameras-overview/dynamic-resolution/frame-timing-manager"},o="FrameTimingManager",m={unversionedId:"unity/graphics/cameras-overview/dynamic-resolution/FrameTimingManager",id:"version-Unity@2022.1/unity/graphics/cameras-overview/dynamic-resolution/FrameTimingManager",title:"FrameTimingManager",description:"The FrameTimingManager is an API that captures detailed timing data about performance during individual frames in an application. You can use this data to assess those frames to understand why your application doesn\u2019t meet performance targets.",source:"@site/versioned_docs/version-Unity@2022.1/unity/graphics/cameras-overview/dynamic-resolution/frame-timing-manager.md",sourceDirName:"unity/graphics/cameras-overview/dynamic-resolution",slug:"/graphics/cameras-overview/dynamic-resolution/frame-timing-manager",permalink:"/en/docs/graphics/cameras-overview/dynamic-resolution/frame-timing-manager",editUrl:"https://github.com/danyow/danyow.github.io/edit/main/docs/unity/graphics/cameras-overview/dynamic-resolution/frame-timing-manager.md",tags:[],version:"Unity@2022.1",lastUpdatedBy:"danyow",lastUpdatedAt:1648742180,formattedLastUpdatedAt:"3/31/2022",frontMatter:{id:"FrameTimingManager",slug:"/graphics/cameras-overview/dynamic-resolution/frame-timing-manager"},sidebar:"unity",previous:{title:"\u52a8\u6001\u5206\u8fa8\u7387",permalink:"/en/docs/graphics/cameras-overview/dynamic-resolution/dynamic-resolution"},next:{title:"\u591a\u663e\u793a",permalink:"/en/docs/graphics/cameras-overview/multi-display"}},s={},p=[{value:"How to enable the FrameTimingManager",id:"how-to-enable-the-frametimingmanager",level:2},{value:"How to use the FrameTimingManager",id:"how-to-use-the-frametimingmanager",level:2},{value:"View frame time data with a Custom Profiler module",id:"view-frame-time-data-with-a-custom-profiler-module",level:3},{value:"Retrieve timestamp data from the FrameTimingManager C# API",id:"retrieve-timestamp-data-from-the-frametimingmanager-c-api",level:3},{value:"Record data with specific profiler counters",id:"record-data-with-specific-profiler-counters",level:3},{value:"How the FrameTimingManager works",id:"how-the-frametimingmanager-works",level:2},{value:"Possible inaccuracy with tile-based deferred rendering GPUs",id:"possible-inaccuracy-with-tile-based-deferred-rendering-gpus",level:3},{value:"Platform support",id:"platform-support",level:2},{value:"\u5176\u4ed6\u8d44\u6e90",id:"\u5176\u4ed6\u8d44\u6e90",level:2}],u={toc:p};function d(e){var{components:t}=e,a=i(e,["components"]);return(0,r.kt)("wrapper",n({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",n({},{id:"frametimingmanager"}),"FrameTimingManager"),(0,r.kt)("p",null,"The FrameTimingManager is an API that captures detailed timing data about performance during individual frames in an application. You can use this data to assess those frames to understand why your application doesn\u2019t meet performance targets."),(0,r.kt)("p",null,"You can use the FrameTimingManager to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You need to debug at a frame-by-frame level."),(0,r.kt)("li",{parentName:"ul"},"You want to use the ",(0,r.kt)("a",n({parentName:"li"},{href:"/en/docs/graphics/cameras-overview/dynamic-resolution/dynamic-resolution"}),"Dynamic Resolution")," feature."),(0,r.kt)("li",{parentName:"ul"},"You want to use the ",(0,r.kt)("a",n({parentName:"li"},{href:"https://docs.unity.cn/Packages/com.unity.mobile.adaptiveperformance@0.1/manual/index.html"}),"Adaptive Performance")," package.")),(0,r.kt)("p",null,"Frame timings don\u2019t replace data from the ",(0,r.kt)("a",n({parentName:"p"},{href:"/en/docs/unity-overview/analysis/profiler/profiler"}),"Profiler"),"; after you profile your application at a high level, use the FrameTimingManager to investigate specific details. The FrameTimingManager decreases performance when it records data, so it can\u2019t produce an accurate measurement of how your application performs."),(0,r.kt)("h2",n({},{id:"how-to-enable-the-frametimingmanager"}),"How to enable the FrameTimingManager"),(0,r.kt)("p",null," ",(0,r.kt)("strong",{parentName:"p"},"Tip")," : FrameTimingManager is always active for Development Player builds."),(0,r.kt)("p",null,"To enable the FrameTimingManage for Release builds and in the Unity Editor:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Go to  ",(0,r.kt)("strong",{parentName:"li"},"Edit"),"  ",">","  ",(0,r.kt)("strong",{parentName:"li"},"Project Settings"),"  ",">","  ",(0,r.kt)("strong",{parentName:"li"},"Player")," ."),(0,r.kt)("li",{parentName:"ol"},"In  ",(0,r.kt)("strong",{parentName:"li"},"Other Settings")," , navigate to the  ",(0,r.kt)("strong",{parentName:"li"},"Rendering"),"  heading."),(0,r.kt)("li",{parentName:"ol"},"Enable the  ",(0,r.kt)("strong",{parentName:"li"},"Frame Timing Stats"),"  property.")),(0,r.kt)("p",null,"If you use the OpenGL platform, you also need to enable the  ",(0,r.kt)("strong",{parentName:"p"},"OpenGL: Profiler GPU Recorders"),"  property to measure GPU usage. To do this:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Go to  ",(0,r.kt)("strong",{parentName:"li"},"Edit"),"  ",">","  ",(0,r.kt)("strong",{parentName:"li"},"Project"),"  ",">","  ",(0,r.kt)("strong",{parentName:"li"},"Settings"),"  ",">","  ",(0,r.kt)("strong",{parentName:"li"},"Player")," ."),(0,r.kt)("li",{parentName:"ol"},"In  ",(0,r.kt)("strong",{parentName:"li"},"Other Settings")," , navigate to the  ",(0,r.kt)("strong",{parentName:"li"},"Rendering"),"  heading."),(0,r.kt)("li",{parentName:"ol"},"Enable the  ",(0,r.kt)("strong",{parentName:"li"},"OpenGL: Profiler GPU"),"  property.")),(0,r.kt)("p",null,"Note: In Unity versions 2021.2 and earlier, the  ",(0,r.kt)("strong",{parentName:"p"},"OpenGL Profiler GPU Recorder"),"  disables the  ",(0,r.kt)("strong",{parentName:"p"},"Frame Timing Stats"),"  property, so you can\u2019t use them together."),(0,r.kt)("h2",n({},{id:"how-to-use-the-frametimingmanager"}),"How to use the FrameTimingManager"),(0,r.kt)("p",null,"To access data that the FrameTimingManager records, use one of the following methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",n({parentName:"li"},{href:"#view-frame-time-data-with-a-custom-profiler-module"}),"View frame time data in a Custom Profiler module"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",n({parentName:"li"},{href:"#retrieve-timestamp-data-from-the-frame-timing-manager-c-api"}),"Retrieve timestamp data from the FrameTimingManager C# API"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",n({parentName:"li"},{href:"#record-data-with-specific-profiler-counters"}),"Record data through specific profiler counters."))),(0,r.kt)("h3",n({},{id:"view-frame-time-data-with-a-custom-profiler-module"}),"View frame time data with a Custom Profiler module"),(0,r.kt)("p",null,"To view frame timing data in a Custom Profiler module:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create a custom profiler module according to the instructions on ",(0,r.kt)("a",n({parentName:"li"},{href:"/en/docs/unity-overview/analysis/profiler/profiler-customizing/profiler-creating-custom-modules/profiler-module-editor"}),"Creating a custom profiler module"),"."),(0,r.kt)("li",{parentName:"ol"},"In the  ",(0,r.kt)("strong",{parentName:"li"},"Profiler Module Editor"),"  window, select your custom module."),(0,r.kt)("li",{parentName:"ol"},"In the  ",(0,r.kt)("strong",{parentName:"li"},"Available Counters"),"  panel, select  ",(0,r.kt)("strong",{parentName:"li"},"Unity")," ."),(0,r.kt)("li",{parentName:"ol"},"Select  ",(0,r.kt)("strong",{parentName:"li"},"Render"),"  to open the submenu that contains profiler counters related to memory usage, which includes those that the  ",(0,r.kt)("strong",{parentName:"li"},"FrameTimingStats"),"  property enables. You can then click on the relevant counters in the submenu to add them to your custom module.")),(0,r.kt)("p",null,"The following table describes the purpose of each of the counters that become available when you enable  ",(0,r.kt)("strong",{parentName:"p"},"Frame Timing Stats")," :"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Measurement")),(0,r.kt)("th",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"\u63cf\u8ff0")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"CPU Total Frame Time (ms)")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The total CPU frame time, in milliseconds. Unity calculates this as the time between the ends of two frames, including any overheads or time spent waiting in between frames.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"CPU Main Thread Frame Time (ms)")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The time between the start of the frame and the time when the Main Thread finished the work it performed during that frame, in milliseconds.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"CPU Main Thread Present Wait Time (ms)")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The CPU time spent waiting for Present() during the frame.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"CPU Render Thread Frame Time (ms)")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The time between the start of the work on the Render Thread and when Unity calls the Present() function, in milliseconds.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"GPU Frame Time (ms)")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The time difference between the beginning and the end of the GPU rendering a single frame, in milliseconds.")))),(0,r.kt)("h3",n({},{id:"retrieve-timestamp-data-from-the-frametimingmanager-c-api"}),"Retrieve timestamp data from the FrameTimingManager C# API"),(0,r.kt)("p",null,"Use the FrameTimingManager API to access timestamp information. In each variable, the FrameTimingManager records the time a specific event happens during a frame."),(0,r.kt)("p",null,"The following table shows the values available through the API, in the order that Unity executes them during a frame:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"\u5c5e\u6027")),(0,r.kt)("th",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"\u63cf\u8ff0")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"frameStartTimestamp")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The CPU clock time when the frame begins.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"firstSubmitTimestamp")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The CPU clock time when Unity submits the first job to the GPU during this frame.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"cpuTimePresentCalled")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The CPU clock time when Unity calls the Present() function for the current frame.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"cpuTimeFrameComplete")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"The CPU clock time when the GPU finishes rendering the frame and interrupts the CPU.")))),(0,r.kt)("h3",n({},{id:"record-data-with-specific-profiler-counters"}),"Record data with specific profiler counters"),(0,r.kt)("p",null,"You can read FrameTimingManager values using the ProfilerRecorder API instead of the FrameTimingManager C# API. The benefit of this is that when you use the ProfilerRecorder API, the FrameTimingManager only records values when you attach a recorder to a specific counter. This behavior enables you to control which counters collect data and so, reduce the impact that the FrameTimingManager has on performance."),(0,r.kt)("p",null,"The following example shows how to track only the CPU Main Thread Frame Time variable with the ProfilerRecordAPI:"),(0,r.kt)("pre",null,(0,r.kt)("code",n({parentName:"pre"},{}),'\nusing Unity.Profiling;\n\nusing UnityEngine;\n\npublic class ExampleScript : MonoBehaviour\n\n{\n\n    string statsText;\n\n    ProfilerRecorder mainThreadTimeRecorder;\n\n    void OnEnable()\n\n    {\n        mainThreadTimeRecorder = ProfilerRecorder.StartNew(ProfilerCategory.Internal, "CPU Main Thread Frame Time");\n    }\n\n    void OnDisable()\n\n    {\n        mainThreadTimeRecorder.Dispose();\n    }\n\n    void Update()\n\n    {\n\n        var frameTime = mainThreadTimeRecorder.LastValue;\n\n        // Your code logic here\n\n    }\n}\n\n')),(0,r.kt)("h2",n({},{id:"how-the-frametimingmanager-works"}),"How the FrameTimingManager works"),(0,r.kt)("p",null,"The FrameTimingManager provides results with a set delay of four frames. This is because timing results aren\u2019t immediately available at the end of each frame, so the FrameTimingManager waits to get CPU and GPU data for the frame."),(0,r.kt)("p",null,"The delay doesn\u2019t guarantee accurate timing results, because the GPU may not have any available resources to return the results, or might fail to return them correctly."),(0,r.kt)("p",null,"The FrameTimingManger changes how it produces a FrameTimeComplete timestamp under some circumstances:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the GPU supports GPU timestamps, the GPU provides a FrameTimeComplete timestamp."),(0,r.kt)("li",{parentName:"ul"},"If the GPU doesn\u2019t support GPU timestamps and returns GPU Time, the FrameTimingManager calculates a value for gpuFrameTime. The value is the sum of the reported GPU Time and the FirstSubmitTimestamp values."),(0,r.kt)("li",{parentName:"ul"},"If the GPU doesn\u2019t support GPU timestamps and doesn\u2019t return GPU Time,the FrameTimingManager sets the value of PresentTimestamp as the value of FrameTimeComplete.")),(0,r.kt)("h3",n({},{id:"possible-inaccuracy-with-tile-based-deferred-rendering-gpus"}),"Possible inaccuracy with tile-based deferred rendering GPUs"),(0,r.kt)("p",null,"For GPUs that use tile-based deferred rendering architecture, such as Metal GPUs in Apple devices, the reported GPU Time might be larger than the reported frame time."),(0,r.kt)("p",null,"This can happen when the GPU is under heavy load, or when the GPU pipeline is full. In these cases, the GPU might defer execution of some rendering phases. Because the FrameTimingManager measures the time between the beginning and end of the frame rendering, any gaps between phases increase the reported GPU time."),(0,r.kt)("p",null,"In the example below, no GPU resources are available, because the GPU passes a job from the Vertex queue to the Fragment queue. The GPU\u2019s graphics API therefore defers the execution of the next phase. When this happens, the GPU time measurement includes phase work time and any gap in between. The result is that the FrameTimingManager reports a higher GPU time measurement than expected."),(0,r.kt)("p",null,(0,r.kt)("img",n({parentName:"p"},{src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/frame-timing-manager-deferred-rendering-diagram.png",alt:"Diagram showing how the discrepancy in reported GPU time can happen in the Metal API"}))),(0,r.kt)("p",null,"Diagram showing how the discrepancy in reported GPU time can happen in the Metal API"),(0,r.kt)("h2",n({},{id:"platform-support"}),"Platform support"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"\u5c5e\u6027")),(0,r.kt)("th",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"\u63cf\u8ff0")),(0,r.kt)("th",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Supported")),(0,r.kt)("th",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"\u6ce8\u91ca")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"Windows")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"DirectX 11"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),"-> DirectX 12"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null})),(0,r.kt)("td",n({parentName:"tr"},{align:null}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),"-> OpenGL"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null})),(0,r.kt)("td",n({parentName:"tr"},{align:null}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),"-> Vulkan"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null})),(0,r.kt)("td",n({parentName:"tr"},{align:null}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"macOS")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"Metal"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"Might report a larger GPU time measurement than the total frame time due to the behavior of tile-based deferred rendering GPUs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"Linux")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"OpenGL"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u90e8\u5206\u652f\u6301"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"Doesn\u2019t support the GPU time measurement.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),"-> Vulkan"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null})),(0,r.kt)("td",n({parentName:"tr"},{align:null}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"Android")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"OpenGL ES"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),"-> Vulkan"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null})),(0,r.kt)("td",n({parentName:"tr"},{align:null}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"iOS")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"Metal"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"Might report a larger GPU time measurement than the total frame time due to the behavior of tile-based deferred rendering GPUs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"tvOS")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"Metal"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"Might report a larger GPU time measurement than the total frame time due to the behavior of tile-based deferred rendering GPUs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",n({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"td"},"WebGL")),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"WebGL"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"\u90e8\u5206\u652f\u6301"),(0,r.kt)("td",n({parentName:"tr"},{align:null}),"Doesn\u2019t support the GPU time measurement.")))),(0,r.kt)("h2",n({},{id:"\u5176\u4ed6\u8d44\u6e90"}),"\u5176\u4ed6\u8d44\u6e90"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",n({parentName:"li"},{href:"/en/docs/graphics/cameras-overview/dynamic-resolution/dynamic-resolution"}),"Dynamic resolution")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",n({parentName:"li"},{href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/FrameTiming.html"}),"FrameTiming API")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",n({parentName:"li"},{href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/FrameTimingManager.html"}),"FrameTimingManager API")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",n({parentName:"li"},{href:"/en/docs/unity-overview/analysis/profiler/profiler"}),"Profiler overview"))))}d.isMDXComponent=!0}}]);