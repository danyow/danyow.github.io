"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[11785],{35318:function(t,e,a){a.d(e,{Zo:function(){return h},kt:function(){return u}});var i=a(27378);function n(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,i)}return a}function c(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){n(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,i,n=function(t,e){if(null==t)return{};var a,i,n={},r=Object.keys(t);for(i=0;i<r.length;i++)a=r[i],e.indexOf(a)>=0||(n[a]=t[a]);return n}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(i=0;i<r.length;i++)a=r[i],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(n[a]=t[a])}return n}var s=i.createContext({}),l=function(t){var e=i.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):c(c({},e),t)),a},h=function(t){var e=l(t.components);return i.createElement(s.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return i.createElement(i.Fragment,{},e)}},p=i.forwardRef((function(t,e){var a=t.components,n=t.mdxType,r=t.originalType,s=t.parentName,h=o(t,["components","mdxType","originalType","parentName"]),p=l(a),u=n,g=p["".concat(s,".").concat(u)]||p[u]||m[u]||r;return a?i.createElement(g,c(c({ref:e},h),{},{components:a})):i.createElement(g,c({ref:e},h))}));function u(t,e){var a=arguments,n=e&&e.mdxType;if("string"==typeof t||n){var r=a.length,c=new Array(r);c[0]=p;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:n,c[1]=o;for(var l=2;l<r;l++)c[l]=a[l];return i.createElement.apply(null,c)}return i.createElement.apply(null,a)}p.displayName="MDXCreateElement"},44875:function(t,e,a){a.r(e),a.d(e,{assets:function(){return l},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return h}});a(27378);var i=a(35318);function n(){return n=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var a=arguments[e];for(var i in a)Object.prototype.hasOwnProperty.call(a,i)&&(t[i]=a[i])}return t},n.apply(this,arguments)}function r(t,e){if(null==t)return{};var a,i,n=function(t,e){if(null==t)return{};var a,i,n={},r=Object.keys(t);for(i=0;i<r.length;i++)a=r[i],e.indexOf(a)>=0||(n[a]=t[a]);return n}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(i=0;i<r.length;i++)a=r[i],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(n[a]=t[a])}return n}const c={id:"Static batching",slug:"/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/static-batching"},o="Static batching",s={unversionedId:"unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/Static batching",id:"version-Unity@2022.1/unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/Static batching",title:"Static batching",description:"Static batching is a draw call batching method that combines meshes that don\u2019t move to reduce draw calls. It transforms the combined meshes into world space and builds one shared vertex and index buffer for them. Then, for visible meshes, Unity performs a series of simple draw calls, with almost no state changes between each one. Static batching doesn\u2019t reduce the number of draw calls, but instead reduces the number of render state changes between them.",source:"@site/versioned_docs/version-Unity@2022.1/unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/static-batching.md",sourceDirName:"unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching",slug:"/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/static-batching",permalink:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/static-batching",editUrl:"https://github.com/danyow/danyow.github.io/edit/main/docs/unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/static-batching.md",tags:[],version:"Unity@2022.1",lastUpdatedBy:"danyow",lastUpdatedAt:1648742180,formattedLastUpdatedAt:"3/31/2022",frontMatter:{id:"Static batching",slug:"/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/static-batching"},sidebar:"unity",previous:{title:"Dynamic batching",permalink:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/dynamic-batching"},next:{title:"GPU \u5b9e\u4f8b\u5316",permalink:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/gpuinstancing/gpuinstancing"}},l={},h=[{value:"Requirements and compatibility",id:"requirements-and-compatibility",level:2},{value:"Render pipeline compatibility",id:"render-pipeline-compatibility",level:3},{value:"Using static batching",id:"using-static-batching",level:2},{value:"Static batching at build time",id:"static-batching-at-build-time",level:3},{value:"Static batching at runtime",id:"static-batching-at-runtime",level:3},{value:"Performance implications",id:"performance-implications",level:2}],m={toc:h};function p(t){var{components:e}=t,a=r(t,["components"]);return(0,i.kt)("wrapper",n({},m,a,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",n({},{id:"static-batching"}),"Static batching"),(0,i.kt)("p",null,"Static batching is a ",(0,i.kt)("a",n({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/draw-call-batching"}),"draw call batching")," method that combines meshes that don\u2019t move to reduce ",(0,i.kt)("a",n({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/optimizing-draw-calls"}),"draw calls"),". It transforms the combined meshes into world space and builds one shared vertex and index buffer for them. Then, for visible meshes, Unity performs a series of simple draw calls, with almost no state changes between each one. Static batching doesn\u2019t reduce the number of draw calls, but instead reduces the number of render state changes between them."),(0,i.kt)("p",null,"Static batching is more efficient than ",(0,i.kt)("a",n({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/dynamic-batching"}),"dynamic batching")," because static batching doesn\u2019t transform vertices on the CPU. For more information about the performance implications for static batching, see ",(0,i.kt)("a",n({parentName:"p"},{href:"#performance-implications"}),"Performance implications"),"."),(0,i.kt)("h2",n({},{id:"requirements-and-compatibility"}),"Requirements and compatibility"),(0,i.kt)("p",null,"This section includes information about the render pipeline compatibility of static batching."),(0,i.kt)("h3",n({},{id:"render-pipeline-compatibility"}),"Render pipeline compatibility"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",n({parentName:"tr"},{align:null}),(0,i.kt)("strong",{parentName:"th"},"\u529f\u80fd")),(0,i.kt)("th",n({parentName:"tr"},{align:null}),(0,i.kt)("strong",{parentName:"th"},"\u5185\u7f6e\u6e32\u67d3\u7ba1\u7ebf")),(0,i.kt)("th",n({parentName:"tr"},{align:null}),(0,i.kt)("strong",{parentName:"th"},"\u901a\u7528\u6e32\u67d3\u7ba1\u7ebf (URP)")),(0,i.kt)("th",n({parentName:"tr"},{align:null}),(0,i.kt)("strong",{parentName:"th"},"\u9ad8\u6e05\u6e32\u67d3\u7ba1\u7ebf (HDRP)")),(0,i.kt)("th",n({parentName:"tr"},{align:null}),(0,i.kt)("strong",{parentName:"th"},"Custom Scriptable Render Pipeline (SRP)")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",n({parentName:"tr"},{align:null}),(0,i.kt)("strong",{parentName:"td"},"Static Batching")),(0,i.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,i.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,i.kt)("td",n({parentName:"tr"},{align:null}),"\u662f"),(0,i.kt)("td",n({parentName:"tr"},{align:null}),"\u662f")))),(0,i.kt)("h2",n({},{id:"using-static-batching"}),"Using static batching"),(0,i.kt)("p",null,"Unity can perform static batching at build time and at runtime. As a general rule, if the GameObjects exist in a scene before you build your application, use the ",(0,i.kt)("a",n({parentName:"p"},{href:"#static-batching-at-build-time"}),"Editor")," to batch your GameObjects at build time. If you create the GameObjects and their meshes at runtime, use the ",(0,i.kt)("a",n({parentName:"p"},{href:"#static-batching-at-runtime"}),"runtime API"),"."),(0,i.kt)("p",null,"When you use the runtime API, you can change the transform properties of the root of a static batch. This means that you can move, rotate, or scale the entire combination of meshes that make up a static batch. You can\u2019t change the transform properties of the individual meshes."),(0,i.kt)("p",null,"To use static batching for a set of GameObjects, the GameObjects must be eligible for static batching. In addition to the criteria described in the ",(0,i.kt)("a",n({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/draw-call-batching#using-draw-call-batching"}),"common usage information"),", make sure that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The GameObject is active."),(0,i.kt)("li",{parentName:"ul"},"The GameObject has a ",(0,i.kt)("a",n({parentName:"li"},{href:"/en/docs/graphics/mesh/comp-mesh-group/class-mesh-filter"}),"Mesh Filter")," component, and that component is enabled."),(0,i.kt)("li",{parentName:"ul"},"The Mesh Filter component has a reference to a ",(0,i.kt)("a",n({parentName:"li"},{href:"/en/docs/graphics/mesh/class-mesh"}),"Mesh"),"."),(0,i.kt)("li",{parentName:"ul"},"The mesh is read/write enabled."),(0,i.kt)("li",{parentName:"ul"},"The mesh has a vertex count greater than 0."),(0,i.kt)("li",{parentName:"ul"},"The mesh has not already been combined with another Mesh."),(0,i.kt)("li",{parentName:"ul"},"The GameObject has a ",(0,i.kt)("a",n({parentName:"li"},{href:"/en/docs/graphics/mesh/comp-mesh-group/class-mesh-renderer"}),"Mesh Renderer")," component, and that component is enabled."),(0,i.kt)("li",{parentName:"ul"},"The Mesh Renderer component does not use any Material with a shader that has the ",(0,i.kt)("inlineCode",{parentName:"li"},"DisableBatching")," tag set to true."),(0,i.kt)("li",{parentName:"ul"},"Meshes you want to batch together use the same vertex attributes. For example Unity can batch meshes that use vertex position, vertex normal, and one UV with one another, but not with meshes that use vertex position, vertex normal, UV0, UV1, and vertex tangent.")),(0,i.kt)("p",null,"For information about the performance implications for static batching, see ",(0,i.kt)("a",n({parentName:"p"},{href:"#performance-implications"}),"Performance implications"),"."),(0,i.kt)("h3",n({},{id:"static-batching-at-build-time"}),"Static batching at build time"),(0,i.kt)("p",null,"You can enable static batching at build time in the Editor."),(0,i.kt)("p",null,"To perform static batching at build time:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Go to  ",(0,i.kt)("strong",{parentName:"li"},"Edit"),"  ",">","  ",(0,i.kt)("strong",{parentName:"li"},"Project Settings"),"  ",">","  ",(0,i.kt)("strong",{parentName:"li"},"Player")," ."),(0,i.kt)("li",{parentName:"ol"},"In  ",(0,i.kt)("strong",{parentName:"li"},"Other Settings")," , enable  ",(0,i.kt)("strong",{parentName:"li"},"Static Batching")," ."),(0,i.kt)("li",{parentName:"ol"},"In the Scene view or Hierarchy, select the GameObject that you want to batch and view it in the Inspector.",(0,i.kt)("br",null)," ",(0,i.kt)("strong",{parentName:"li"},"Tip")," : You can select multiple GameObjects at the same time to enable static batching for all of them."),(0,i.kt)("li",{parentName:"ol"},"In the GameObject\u2019s ",(0,i.kt)("a",n({parentName:"li"},{href:"/en/docs/unity-overview/creating-gameplay/game-objects/static-objects"}),"Static Editor Flags"),", enable  ",(0,i.kt)("strong",{parentName:"li"},"Batching Static")," .")),(0,i.kt)("p",null,"Unity automatically batches the specified static meshes into the same draw call if they fulfill the criteria described in the ",(0,i.kt)("a",n({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/draw-call-batching#using-draw-call-batching"}),"common usage information"),"."),(0,i.kt)("p",null,(0,i.kt)("img",n({parentName:"p"},{src:"https://docs.unity3d.com/cn/2022.1/uploads/Main/StaticTagInspector.png",alt:"The Static Editor Flags checkbox in the Inspector for a GameObject."}))),(0,i.kt)("p",null,"The Static Editor Flags checkbox in the Inspector for a GameObject."),(0,i.kt)("p",null," ",(0,i.kt)("strong",{parentName:"p"},"Note")," : If you perform static batching at build time, Unity doesn\u2019t use any CPU resources at runtime to generate the mesh data for the static batch."),(0,i.kt)("h3",n({},{id:"static-batching-at-runtime"}),"Static batching at runtime"),(0,i.kt)("p",null,"To batch static meshes at runtime, Unity provides the ",(0,i.kt)("a",n({parentName:"p"},{href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/StaticBatchingUtility.html"}),"StaticBatchingUtility")," class. The static ",(0,i.kt)("a",n({parentName:"p"},{href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/StaticBatchingUtility.Combine.html"}),"StaticBatchingUtility.Combine")," method combines the GameObjects you pass in and prepares them for static batching. This is especially useful for meshes that you procedurally generate at runtime."),(0,i.kt)("p",null,"Unlike static batching at build time, batching at runtime doesn\u2019t require you to enable the  ",(0,i.kt)("strong",{parentName:"p"},"Static Batching"),"  Player Setting. For information on how to use this API, see ",(0,i.kt)("a",n({parentName:"p"},{href:"https://docs.unity3d.com/cn/2022.1/ScriptReference/StaticBatchingUtility.html"}),"StaticBatchingUtility"),"."),(0,i.kt)("h2",n({},{id:"performance-implications"}),"Performance implications"),(0,i.kt)("p",null,"Using static batching requires additional CPU memory to store the combined geometry. If multiple GameObjects use the same mesh, Unity creates a copy of the mesh for each GameObject, and inserts each copy into the combined mesh. This means that the same geometry appears in the combined mesh multiple times. Unity does this regardless of whether you use the ",(0,i.kt)("a",n({parentName:"p"},{href:"#static-batching-at-build-time"}),"editor")," or ",(0,i.kt)("a",n({parentName:"p"},{href:"#static-batching-at-runtime"}),"runtime API")," to prepare the GameObjects for static batching. If you want to keep a smaller memory footprint, you might have to sacrifice rendering performance and avoid static batching for some GameObjects. For example, marking trees as static in a dense forest environment can have a serious memory impact."),(0,i.kt)("p",null," ",(0,i.kt)("strong",{parentName:"p"},"Note")," : There are limits to the number of vertices a static batch can include. Each static batch can include up to 64000 vertices. If there are more, Unity creates another batch."))}p.isMDXComponent=!0}}]);