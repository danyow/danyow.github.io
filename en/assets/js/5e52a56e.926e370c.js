"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8485],{5318:function(n,t,e){e.d(t,{Zo:function(){return i},kt:function(){return f}});var a=e(7378);function l(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,a)}return e}function c(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){l(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function u(n,t){if(null==n)return{};var e,a,l=function(n,t){if(null==n)return{};var e,a,l={},r=Object.keys(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||(l[e]=n[e]);return l}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(l[e]=n[e])}return l}var o=a.createContext({}),s=function(n){var t=a.useContext(o),e=t;return n&&(e="function"==typeof n?n(t):c(c({},t),n)),e},i=function(n){var t=s(n.components);return a.createElement(o.Provider,{value:t},n.children)},p={inlineCode:"code",wrapper:function(n){var t=n.children;return a.createElement(a.Fragment,{},t)}},L=a.forwardRef((function(n,t){var e=n.components,l=n.mdxType,r=n.originalType,o=n.parentName,i=u(n,["components","mdxType","originalType","parentName"]),L=s(e),f=l,d=L["".concat(o,".").concat(f)]||L[f]||p[f]||r;return e?a.createElement(d,c(c({ref:t},i),{},{components:e})):a.createElement(d,c({ref:t},i))}));function f(n,t){var e=arguments,l=t&&t.mdxType;if("string"==typeof n||l){var r=e.length,c=new Array(r);c[0]=L;var u={};for(var o in t)hasOwnProperty.call(t,o)&&(u[o]=t[o]);u.originalType=n,u.mdxType="string"==typeof n?n:l,c[1]=u;for(var s=2;s<r;s++)c[s]=e[s];return a.createElement.apply(null,c)}return a.createElement.apply(null,e)}L.displayName="MDXCreateElement"},6568:function(n,t,e){e.r(t),e.d(t,{assets:function(){return s},contentTitle:function(){return u},default:function(){return L},frontMatter:function(){return c},metadata:function(){return o},toc:function(){return i}});e(7378);var a=e(5318);function l(){return l=Object.assign||function(n){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&(n[a]=e[a])}return n},l.apply(this,arguments)}function r(n,t){if(null==n)return{};var e,a,l=function(n,t){if(null==n)return{};var e,a,l={},r=Object.keys(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||(l[e]=n[e]);return l}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(l[e]=n[e])}return l}const c={id:"lua-try-catch",title:"\u6d45\u6790lua\u5f02\u5e38\u6355\u83b7\u5904\u7406\u673a\u5236",slug:"/reprint/lua-try-catch"},u=void 0,o={unversionedId:"reprint/lua-try-catch",id:"reprint/lua-try-catch",title:"\u6d45\u6790lua\u5f02\u5e38\u6355\u83b7\u5904\u7406\u673a\u5236",description:"\u5f02\u5e38\u6355\u83b7\u662f\u9ad8\u7ea7\u8bed\u8a00\u7684\u4e00\u5927\u7279\u6027\uff0c\u901a\u8fc7\u5bf9\u5f02\u5e38\u5730\u6355\u83b7\u548c\u5904\u7406\uff0c\u53ef\u4ee5\u6709\u6548\u63d0\u9ad8\u7cfb\u7edf\u7684\u7a33\u5b9a\u6027\u548c\u5065\u58ee\u6027\u3002\u56e0\u4e3a\u65e0\u8bba\u518d\u600e\u6837\u6539\u8fdb\u4ee3\u7801\uff0c\u90fd\u4e0d\u53ef\u907f\u514d\u51fa\u73b0\u4e00\u4e9b\u5f02\u5e38\uff0c\u4f8b\u5982\u6587\u4ef6io\u9519\u8bef\u3001\u7f51\u7edc\u9519\u8bef\u3001\u5185\u5b58\u9519\u8bef\u7b49\u7b49\uff0c\u5c31\u8981\u6c42\u7f16\u7801\u5bf9\u9519\u8bef\u8fdb\u884c\u6355\u83b7\uff0c\u540c\u65f6\u6253\u5370\u65e5\u5fd7\u4ee5\u4fbf\u5f00\u53d1\u4eba\u5458\u8ddf\u8fdb\u95ee\u9898\u7684\u5904\u7406\u3002\u5f53\u7136\uff0clua\u4e5f\u63d0\u4f9b\u4e86\u63a5\u53e3\u7528\u4e8e\u6355\u83b7\u8fd0\u884c\u65f6\u5f02\u5e38\u3002",source:"@site/docs/reprint/lua-try-catch.md",sourceDirName:"reprint",slug:"/reprint/lua-try-catch",permalink:"/en/docs/reprint/lua-try-catch",editUrl:"https://github.com/danyow/danyow.github.io/edit/main/docs/reprint/lua-try-catch.md",tags:[],version:"current",lastUpdatedBy:"danyow",lastUpdatedAt:1649693492,formattedLastUpdatedAt:"4/11/2022",frontMatter:{id:"lua-try-catch",title:"\u6d45\u6790lua\u5f02\u5e38\u6355\u83b7\u5904\u7406\u673a\u5236",slug:"/reprint/lua-try-catch"},sidebar:"docs",previous:{title:"lua GC \u7684\u5de5\u4f5c\u539f\u7406",permalink:"/en/docs/reprint/lua-gc-principle"},next:{title:"\u7ffb\u8bd1",permalink:"/en/docs/translation"}},s={},i=[{value:"lua\u5f02\u5e38\u6355\u83b7\u51fd\u6570",id:"lua\u5f02\u5e38\u6355\u83b7\u51fd\u6570",level:2},{value:"lua\u5f02\u5e38\u6355\u83b7\u5904\u7406\u673a\u5236",id:"lua\u5f02\u5e38\u6355\u83b7\u5904\u7406\u673a\u5236",level:2},{value:"pcall\u7684\u5b9e\u73b0",id:"pcall\u7684\u5b9e\u73b0",level:3},{value:"xpcall\u548cpcall\u7684\u533a\u522b",id:"xpcall\u548cpcall\u7684\u533a\u522b",level:3},{value:"\u62d3\u5c55\u9605\u8bfb",id:"\u62d3\u5c55\u9605\u8bfb",level:2},{value:"lua state\u4e4bnny",id:"lua-state\u4e4bnny",level:3}],p={toc:i};function L(n){var{components:t}=n,e=r(n,["components"]);return(0,a.kt)("wrapper",l({},p,e,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"\u5f02\u5e38\u6355\u83b7\u662f\u9ad8\u7ea7\u8bed\u8a00\u7684\u4e00\u5927\u7279\u6027\uff0c\u901a\u8fc7\u5bf9\u5f02\u5e38\u5730\u6355\u83b7\u548c\u5904\u7406\uff0c\u53ef\u4ee5\u6709\u6548\u63d0\u9ad8\u7cfb\u7edf\u7684\u7a33\u5b9a\u6027\u548c\u5065\u58ee\u6027\u3002\u56e0\u4e3a\u65e0\u8bba\u518d\u600e\u6837\u6539\u8fdb\u4ee3\u7801\uff0c\u90fd\u4e0d\u53ef\u907f\u514d\u51fa\u73b0\u4e00\u4e9b\u5f02\u5e38\uff0c\u4f8b\u5982\u6587\u4ef6io\u9519\u8bef\u3001\u7f51\u7edc\u9519\u8bef\u3001\u5185\u5b58\u9519\u8bef\u7b49\u7b49\uff0c\u5c31\u8981\u6c42\u7f16\u7801\u5bf9\u9519\u8bef\u8fdb\u884c\u6355\u83b7\uff0c\u540c\u65f6\u6253\u5370\u65e5\u5fd7\u4ee5\u4fbf\u5f00\u53d1\u4eba\u5458\u8ddf\u8fdb\u95ee\u9898\u7684\u5904\u7406\u3002\u5f53\u7136\uff0clua\u4e5f\u63d0\u4f9b\u4e86\u63a5\u53e3\u7528\u4e8e\u6355\u83b7\u8fd0\u884c\u65f6\u5f02\u5e38\u3002"),(0,a.kt)("h2",l({},{id:"lua\u5f02\u5e38\u6355\u83b7\u51fd\u6570"}),"lua\u5f02\u5e38\u6355\u83b7\u51fd\u6570"),(0,a.kt)("p",null,"lua\u6709\u4e24\u4e2a\u51fd\u6570\u53ef\u7528\u4e8e\u6355\u83b7\u5f02\u5e38\uff1apcall \u548c xpcall\uff0c\u8fd9\u4e24\u4e2a\u51fd\u6570\u5f88\u7c7b\u4f3c\uff0c\u90fd\u4f1a\u5728\u4fdd\u62a4\u6a21\u5f0f\u4e0b\u6267\u884c\u51fd\u6570\uff0c\u6548\u679c\u7c7b\u4f3ctry-catch\uff0c\u53ef\u6355\u83b7\u5e76\u5904\u7406\u5f02\u5e38\u3002"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u4e24\u4e2a\u51fd\u6570\u7684\u539f\u578b\u5982\u4e0b\uff1a")),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-lua"}),"pcall (func [, arg1, \xb7\xb7\xb7])\nxpcall (func, errfunc [, arg1, \xb7\xb7\xb7])\n")),(0,a.kt)("p",null,"\u5bf9\u6bd4\u4e24\u4e2a\u51fd\u6570\uff0cxpcall\u591a\u4e86\u4e00\u4e2a\u5f02\u5e38\u5904\u7406\u51fd\u6570\u53c2\u6570\nerrfunc\u3002\u5bf9\u4e8epcall\uff0c\u5f02\u5e38\u5904\u7406\u5b8c\u65f6\u53ea\u7b80\u5355\u8bb0\u5f55\u9519\u8bef\u4fe1\u606f\uff0c\u7136\u540e\u91ca\u653e\u8c03\u7528\u6808\u7a7a\u95f4\uff0c\u800c\u5bf9\u4e8expcall\uff0c\u8fd9\u4e2a\u53c2\u6570\u53ef\u7528\u4e8e\u5728\u8c03\u7528\u6808\u91ca\u653e\u524d\u8ddf\u8e2a\u5230\u8fd9\u4e9b\u6570\u636e\u3002\u6548\u679c\u5982\u4e0b\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-shell"}),"> f=function(...) error(...) end\n> pcall(f, 123)\nfalse   stdin:1: 123\n> xpcall(f, function(e) print(debug.traceback()) return e end, 123)\nstack traceback:\n        stdin:1: in function <stdin:1>\n        [C]: in function 'error'\n        stdin:1: in function 'f'\n        [C]: in function 'xpcall'\n        stdin:1: in main chunk\n        [C]: in ?\nfalse   stdin:1: 123\n")),(0,a.kt)("p",null,"\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c errfunc\u7684\u4f20\u5165\u53c2\u6570\u662f\u5f02\u5e38\u6570\u636e\uff0c\u51fd\u6570\u7ed3\u675f\u65f6\u5fc5\u987b\u5c06\u8fd9\u4e2a\u6570\u636e\u8fd4\u56de\uff0c\u624d\u80fd\u5b9e\u73b0\u548c pcall \u4e00\u6837\u7684\u8fd4\u56de\u503c"),(0,a.kt)("h2",l({},{id:"lua\u5f02\u5e38\u6355\u83b7\u5904\u7406\u673a\u5236"}),"lua\u5f02\u5e38\u6355\u83b7\u5904\u7406\u673a\u5236"),(0,a.kt)("p",null,"\u4e0b\u9762\uff0c\u4ee5 pcall \u6765\u8bf4\u660e lua\u5f02\u5e38\u6355\u83b7\u662f\u600e\u4e48\u5b9e\u73b0\u7684\u3002\u8fd9\u91cc\uff0clua\u4ee3\u7801\u7248\u672c\u53d65.3.1"),(0,a.kt)("h3",l({},{id:"pcall\u7684\u5b9e\u73b0"}),"pcall\u7684\u5b9e\u73b0"),(0,a.kt)("p",null,"pcall\u7684c\u5b9e\u73b0\u51fd\u6570\u4e3aluaB_pcall\uff0c\u5982\u4e0b\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// lbaselib.c\nstatic int luaB_pcall (lua_State *L) {\n  int status;\n  luaL_checkany(L, 1);\n  lua_pushboolean(L, 1);  // \u5982\u679c\u6ca1\u9519\u8bef\u53d1\u751f\uff0c\u8fd4\u56detrue\n  lua_insert(L, 1);  /* put it in place */\n  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);\n  return finishpcall(L, status, 0);\n}\n")),(0,a.kt)("p",null,"\u770b\u4e0blua_pcallk\uff0c\u8fd9\u662fpcall\u7684\u9884\u5904\u7406\u51fd\u6570\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// lapi.c\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        lua_KContext ctx, lua_KFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2addr(L, errfunc);\n    api_checkstackindex(L, errfunc, o);\n    func = savestack(L, o); \n  }\n  c.func = L->top - (nargs+1);  // \u53d6\u5230pcall\u8981\u6267\u884c\u7684\u51fd\u6570\n  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */\n    c.nresults = nresults;  /* do a 'conventional' protected call */\n    /* \u5904\u7406pcall\uff08\u975e\u534f\u7a0b\u8d70\u8fd9\u91cc\uff0c\u8be6\u89c1\u62d3\u5c55\u9605\u8bfb\uff09*/\n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func); \n  }\n  else {  //\u5f53resume\u534f\u7a0b\u65f6\u6267\u884c\uff0c\u5df2\u5728\u4fdd\u62a4\u6a21\u5f0f\u4e0b\n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;  /* save continuation */\n    ci->u.c.ctx = ctx;  /* save context */\n    /* save information for error recovery */\n    ci->extra = savestack(L, c.func);\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func; // \u8bb0\u5f55\u5f02\u5e38\u5904\u7406\u51fd\u6570\n    setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */\n    ci->callstatus |= CIST_YPCALL;  // \u6253\u6807\u8bb0\u8bbe\u7f6e\u534f\u7a0b\u6062\u590d\u70b9\n    luaD_call(L, c.func, nresults, 1);  /* do the call */\n    ci->callstatus &= ~CIST_YPCALL; // \u6267\u884c\u7ed3\u675f\u53bb\u6389\u6807\u8bb0\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;  /* if it is here, there were no errors */\n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}\n")),(0,a.kt)("p",null,"\u8fd9\u91cc\u91cd\u70b9\u770b\u4e0b luaD_pcall \u7684\u5b9e\u73b0\uff0c\u8fd9\u662fpcall\u7684\u6838\u5fc3\u5904\u7406\u51fd\u6570\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// ldo.c \nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  unsigned short old_nny = L->nny;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef; // \u8bb0\u5f55\u5f02\u5e38\u5904\u7406\u51fd\u6570\n  status = luaD_rawrunprotected(L, func, u); // \u4ee5\u4fdd\u62a4\u6a21\u5f0f\u8fd0\u884c\n  if (status != LUA_OK) {  // \u5f53\u5f02\u5e38\u53d1\u751f\u65f6\n    StkId oldtop = restorestack(L, old_top); // \u2018\u91ca\u653e\u2019\u8c03\u7528\u6808\n    luaF_close(L, oldtop);  /* close possible pending closures */\n    seterrorobj(L, status, oldtop);\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    L->nny = old_nny;\n    luaD_shrinkstack(L);\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n")),(0,a.kt)("p",null,"\u770b\u4e0b luaD_rawrunprotected \u51fd\u6570\u7684\u5b9e\u73b0\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// ldo.c \nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  unsigned short oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj,    (*f)(L, ud);  ); // \u5f02\u5e38\u5b8f\u5904\u7406\n  L->errorJmp = lj.previous;  // \u8bbe\u7f6e\u9519\u8bef\u8df3\u8f6c\u70b9\n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}\n")),(0,a.kt)("p",null,"LUAI_TRY \u4ee5\u53ca\u6587\u7ae0\u540e\u9762\u51fa\u73b0\u7684LUAI_THROW\n\u90fd\u662f\u5b8f\u5b9e\u73b0\u7684\uff0c\u76ee\u7684\u662f\u517c\u5bb9\u4e3b\u6d41c\u6216c++\u7248\u672c\u7684\u5f02\u5e38\u5904\u7406\u8bed\u6cd5\uff0c\u8868\u73b0\u4e3atry-catch\u7684\u8bed\u6cd5\u7ed3\u6784\u3002\u7b80\u5355\u8bf4\u5c31\u662f\uff0c\u6267\u884c\u4ee3\u7801\u524d\u5148try\uff0c\u6267\u884c\u8fc7\u7a0b\u51fa\u9519\u5c31throw\uff0c\u7136\u540e\u5728catch\u7684\u5730\u65b9\u5904\u7406\u5f02\u5e38\u3002"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"/*\n** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By\n** default, Lua handles errors with exceptions when compiling as\n** C++ code, with _longjmp/_setjmp when asked to use them, and with\n** longjmp/setjmp otherwise.\n*/\n#if !defined(LUAI_THROW)     /* { */\n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)   /* { */\n\n/* C++ exceptions */\n#define LUAI_THROW(L,c)  throw(c)\n#define LUAI_TRY(L,c,a) \\\n try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf  int  /* dummy variable */\n\n#elif defined(LUA_USE_POSIX)     /* }{ */\n\n/* in POSIX, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)  _longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)  if (_setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf  jmp_buf\n\n#else    /* }{ */\n\n/* ISO C handling with long jumps */\n#define LUAI_THROW(L,c)  longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,a)  if (setjmp((c)->b) == 0) { a }\n#define luai_jmpbuf  jmp_buf\n\n#endif   /* } */\n\n#endif   /* } */\n")),(0,a.kt)("p",null,"\u5f53\u5f02\u5e38\u51fa\u73b0\u65f6\uff0cstatus \u5c31\u4f1a\u8d4b\u503c\u4e3a-1\uff0c\u5373\u4e0d\u7b49\u4e8e LUA_OK"),(0,a.kt)("h3",l({},{id:"xpcall\u548cpcall\u7684\u533a\u522b"}),"xpcall\u548cpcall\u7684\u533a\u522b"),(0,a.kt)("p",null,"\u5bf9\u6bd4\u4e0bxpcall\u5bf9\u6bd4pcall\uff0c\u6709\u4ec0\u4e48\u533a\u522b\uff1f"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// lbaselib.c\nstatic int luaB_pcall (lua_State *L) {\n  int status;\n  luaL_checkany(L, 1);\n  lua_pushboolean(L, 1);  /* first result if no errors */\n  lua_insert(L, 1);  /* put it in place */\n  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);\n  return finishpcall(L, status, 0);\n}\n\n\nstatic int luaB_xpcall (lua_State *L) {\n  int status;\n  int n = lua_gettop(L);\n  luaL_checktype(L, 2, LUA_TFUNCTION);  /* check error function */\n  lua_pushboolean(L, 1);  /* first result */\n  lua_pushvalue(L, 1);  // \u5c06\u5f02\u5e38\u5904\u7406\u51fd\u6570 errfunc \u5199\u5165\u8c03\u7528\u6808\n  lua_rotate(L, 3, 2);  /* move them below function's arguments */\n  status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);\n  return finishpcall(L, status, 2);\n}\n")),(0,a.kt)("p",null,"\u518d\u56de\u5934\u770b\u4e0blua_pcallk"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),'// lapi.c\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        lua_KContext ctx, lua_KFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    "cannot use continuations inside hooks");\n  api_checknelems(L, nargs+1);\n  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0; // pcall\u65f6 func\u4e3a0\n  else {\n    StkId o = index2addr(L, errfunc);\n    api_checkstackindex(L, errfunc, o);\n    func = savestack(L, o); // xpcall\u53d6\u5230\u5f02\u5e38\u5904\u7406\u51fd\u6570 errfunc\n  }\n')),(0,a.kt)("p",null,"\u7136\u540e\uff0c func \u8d4b\u503c\u7ed9 L->errfunc\uff0c\u5728\u5f02\u5e38\u53d1\u751f\u65f6\uff0c\u5c31\u68c0\u67e5\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u3002"),(0,a.kt)("p",null,"\u4ec0\u4e48\u5730\u65b9\u6267\u884c\u8fd9\u4e2a\u9519\u8bef\u5904\u7406\u51fd\u6570\uff1f"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// ldebug.c\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {  // \u5982\u679c\u6709\u5f02\u5e38\u5904\u7406\u51fd\u6570 errfunc \n    StkId errfunc = restorestack(L, L->errfunc); \n    setobjs2s(L, L->top, L->top - 1);  /* move argument */\n    setobjs2s(L, L->top - 1, errfunc);  /* push function */\n    L->top++;  /* assume EXTRA_STACK */\n    luaD_call(L, L->top - 2, 1, 0);  /* call it */\n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n")),(0,a.kt)("p",null,"luaD_throw\u5219\u662f\u8c03\u7528 LUAI_THROW\uff0c\u8df3\u5230\u524d\u9762catch\u7684\u4f4d\u7f6e"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// ldo.c\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {  /* thread has an error handler? */\n    L->errorJmp->status = errcode;  /* set status */\n    LUAI_THROW(L, L->errorJmp);  /* jump to it */\n  }\n  else {  /* thread has no error handler */\n    global_State *g = G(L);\n    L->status = cast_byte(errcode);  /* mark it as dead */\n    if (g->mainthread->errorJmp) {  /* main thread has a handler? */\n      setobjs2s(L, g->mainthread->top++, L->top - 1);  /* copy error obj. */\n      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */\n    }\n    else {  /* no handler at all; abort */\n      if (g->panic) {  /* panic function? */\n        seterrorobj(L, errcode, L->top);  /* assume EXTRA_STACK */\n        if (L->ci->top < L->top)\n          L->ci->top = L->top;  /* pushing msg. can break this invariant */\n        lua_unlock(L);\n        g->panic(L);  /* call panic function (last chance to jump out) */\n      }\n      abort();\n    }\n  }\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u4e24\u79cd\u60c5\u51b5\u4f1a\u89e6\u53d1\u8fd9\u4e2a\u51fd\u6570")),(0,a.kt)("p",null,"1\u3001\u4e3b\u52a8\u8c03\u7528error\u65f6\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// lapi.c\nLUA_API int lua_error (lua_State *L) {\n  lua_lock(L);\n  api_checknelems(L, 1);\n  luaG_errormsg(L);\n  /* code unreachable; will unlock when control actually leaves the kernel */\n  return 0;  /* to avoid warnings */\n}\n")),(0,a.kt)("p",null,"2\u3001\u51fa\u73b0\u8fd0\u884c\u65f6\u9519\u8bef\u65f6\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// ldebug.c\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci))  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, currentline(ci));\n  luaG_errormsg(L);\n}\n")),(0,a.kt)("h2",l({},{id:"\u62d3\u5c55\u9605\u8bfb"}),"\u62d3\u5c55\u9605\u8bfb"),(0,a.kt)("h3",l({},{id:"lua-state\u4e4bnny"}),"lua state\u4e4bnny"),(0,a.kt)("p",null,"\u5728lua state\u4e2d\uff0cnny\u8bb0\u5f55\u4e86\u8c03\u7528\u6808\u4e0a\u4e0d\u80fd\u88ab\u6302\u8d77\u7684\u6b21\u6570\uff0c\u5b9a\u4e49\u5728 lua_State\u7ed3\u6784\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"struct lua_State {\n  CommonHeader;\n  lu_byte status;\n  StkId top;  /* first free slot in the stack */\n  global_State *l_G;\n  CallInfo *ci;  /* call info for current function */\n  const Instruction *oldpc;  /* last pc traced */\n  StkId stack_last;  /* last free slot in the stack */\n  StkId stack;  /* stack base */\n  UpVal *openupval;  /* list of open upvalues in this stack */\n  GCObject *gclist;\n  struct lua_State *twups;  /* list of threads with open upvalues */\n  struct lua_longjmp *errorJmp;  /* current error recover point */\n  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */\n  lua_Hook hook;\n  ptrdiff_t errfunc;  /* current error handling function (stack index) */\n  int stacksize;\n  int basehookcount;\n  int hookcount;\n  unsigned short nny;  /* number of non-yieldable calls in stack */\n  unsigned short nCcalls;  /* number of nested C calls */\n  lu_byte hookmask;\n  lu_byte allowhook;\n};\n")),(0,a.kt)("p",null,"\u4e3a\u4ec0\u4e48lua state\u9700\u8981\u8fd9\u4e2a\u5b57\u6bb5\uff1f"),(0,a.kt)("p",null,"\u8fd9\u662f\u56e0\u4e3apcall\u8c03\u7528\u51fd\u6570\u4e2d\u8fd8\u53ef\u4ee5\u6709pcall\uff0c\u652f\u6301\u591a\u5c42\u5d4c\u5957\uff0c\u6240\u4ee5\u9700\u8981\u8bb0\u5f55\u4e00\u4e2a\u6b21\u6570\u503c\uff0c\u5728pcall\u6267\u884c\u524d+1\uff0c\u7ed3\u675f\u540e-1"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),'/*\n** Call a function (C or Lua). The function to be called is at *func.\n** The arguments are on the stack, right after the function.\n** When returns, all the results are on the stack, starting at the original\n** function position.\n*/\nvoid luaD_call (lua_State *L, StkId func, int nResults, int allowyield) {\n  fprintf(stderr, "luaD_call %d\\n", allowyield);\n  if (++L->nCcalls >= LUAI_MAXCCALLS) {\n    if (L->nCcalls == LUAI_MAXCCALLS)\n      luaG_runerror(L, "C stack overflow");\n    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))\n      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */\n  }\n  if (!allowyield) L->nny++;\n  if (!luaD_precall(L, func, nResults))  /* is a Lua function? */\n    luaV_execute(L);  /* call it */\n  if (!allowyield) L->nny--;\n  L->nCcalls--;\n}\n')),(0,a.kt)("p",null,"\u8fd9\u6837\uff0c\u901a\u8fc7\u5224\u65ad nny\u7684\u503c\uff0c\u5c31\u53ef\u4ee5\u77e5\u9053\u5f53\u524d\u8fc7\u7a0b\u80fd\u5426\u6302\u8d77\u3002"),(0,a.kt)("p",null,"\u7ec6\u5fc3\u7684\u540c\u5b66\u4f1a\u53d1\u73b0\uff0c luaD_call\u662f\u5728pcall\u7684\u6267\u884c\u8fc7\u7a0b\u8c03\u7528\u5230\u7684\uff0c \u4e3a\u4ec0\u4e48 L->nny\u4f1a\u5927\u4e8e0\uff1f"),(0,a.kt)("p",null,"\u8fd9\u662f\u56e0\u4e3alua \u865a\u62df\u673a\uff08lua state\uff09\u542f\u52a8\u65f6 L->nny \u5c31\u8d4b\u503c1\u4e86"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// lstate.c\nLUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {\n  int i;\n  lua_State *L;\n  global_State *g;\n  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));\n  if (l == NULL) return NULL;\n  L = &l->l.l;\n  g = &l->g;\n  L->next = NULL;\n  L->tt = LUA_TTHREAD;\n  g->currentwhite = bitmask(WHITE0BIT);\n  L->marked = luaC_white(g);\n  preinit_thread(L, g);  // \u9884\u5904\u7406\u534f\u7a0b\u65f6\u5c06 L->nny \u8d4b\u503c1\n  g->frealloc = f;\n  g->ud = ud;\n  g->mainthread = L;\n  g->seed = makeseed(L);\n  g->gcrunning = 0;  /* no GC while building state */\n  g->GCestimate = 0;\n  g->strt.size = g->strt.nuse = 0;\n  g->strt.hash = NULL;\n  setnilvalue(&g->l_registry);\n  luaZ_initbuffer(L, &g->buff);\n  g->panic = NULL;\n  g->version = NULL;\n  g->gcstate = GCSpause;\n  g->gckind = KGC_NORMAL;\n  g->allgc = g->finobj = g->tobefnz = g->fixedgc = NULL;\n  g->sweepgc = NULL;\n  g->gray = g->grayagain = NULL;\n  g->weak = g->ephemeron = g->allweak = NULL;\n  g->twups = NULL;\n  g->totalbytes = sizeof(LG);\n  g->GCdebt = 0;\n  g->gcfinnum = 0;\n  g->gcpause = LUAI_GCPAUSE;\n  g->gcstepmul = LUAI_GCMUL;\n  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;\n  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {\n    /* memory allocation error: free partial state */\n    close_state(L);\n    L = NULL;\n  }\n  return L;\n}\n")),(0,a.kt)("p",null,"\u770b\u4e0b preinit_thread \u51fd\u6570\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// lstate.c\n/*\n** preinitialize a thread with consistent values without allocating\n** any memory (to avoid errors)\n*/\nstatic void preinit_thread (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->stacksize = 0;\n  L->twups = L;  /* thread has no upvalues */\n  L->errorJmp = NULL;\n  L->nCcalls = 0;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->nny = 1; //\u5c06 L->nny \u8d4b\u503c1\n  L->status = LUA_OK;\n  L->errfunc = 0;\n}\n")),(0,a.kt)("p",null,"\u90a3\u534f\u7a0b lua_newthread\u65f6\u4e5f\u4f1a\u8c03\u7528 preinit_thread \uff0c\u4f46\u662f\u4e24\u8005\u5bf9\u4e8epcall\u7684\u5b9e\u73b0\u5374\u6709\u4e0d\u5c11\u7684\u5dee\u5f02\u3002"),(0,a.kt)("p",null,"\u5982\u4e0b\uff0c\u534f\u7a0b\u521b\u5efa\u65f6\u8c03\u7528 preinit_thread \u9884\u5904\u7406 \u534f\u7a0b\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"// lstate.c\nLUA_API lua_State *lua_newthread (lua_State *L) {\n  global_State *g = G(L);\n  lua_State *L1;\n  lua_lock(L);\n  luaC_checkGC(L);\n  /* create new thread */\n  L1 = &cast(LX *, luaM_newobject(L, LUA_TTHREAD, sizeof(LX)))->l;\n  L1->marked = luaC_white(g);\n  L1->tt = LUA_TTHREAD;\n  /* link it on list 'allgc' */\n  L1->next = g->allgc;\n  g->allgc = obj2gco(L1);\n  /* anchor it on L stack */\n  setthvalue(L, L->top, L1);\n  api_incr_top(L);\n  preinit_thread(L1, g);  // \u9884\u5904\u7406\u534f\u7a0b\u65f6\u5c06 L->nny \u8d4b\u503c1\n  L1->hookmask = L->hookmask;\n  L1->basehookcount = L->basehookcount;\n  L1->hook = L->hook;\n  resethookcount(L1);\n  /* initialize L1 extra space */\n  memcpy(lua_getextraspace(L1), lua_getextraspace(g->mainthread),\n         LUA_EXTRASPACE);\n  luai_userstatethread(L, L1);\n  stack_init(L1, L);  /* init stack */\n  lua_unlock(L);\n  return L1;\n}\n")),(0,a.kt)("p",null,"\u4f46\u662f\uff0c\u534f\u7a0b\u5728lua\u4e2d\u662f\u8fd9\u6837\u8c03\u7528\u7684\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-lua"}),"local co = coroutine.create(func)\ncoroutine.resume(co)\n")),(0,a.kt)("p",null,"\u518d\u770b\u4e0b resume\u7684\u5b9e\u73b0\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-c"}),"LUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {\n  int status;\n  int oldnny = L->nny;  /* save \"number of non-yieldable\" calls */\n  lua_lock(L);\n  luai_userstateresume(L, nargs);\n  L->nCcalls = (from) ? from->nCcalls + 1 : 1;\n  L->nny = 0;  // \u5c06 nny\u8d4b\u503c 0\uff0c\u5141\u8bb8\u6302\u8d77\n  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume, &nargs); // \u5728\u4fdd\u62a4\u6a21\u5f0f\u542f\u52a8\u534f\u7a0b\n  if (status == -1)  /* error calling 'lua_resume'? */\n    status = LUA_ERRRUN;\n  else {  /* continue running after recoverable errors */\n    while (errorstatus(status) && recover(L, status)) { // \u68c0\u67e5\u662f\u5426\u6709\u53ef\u6062\u590d\u70b9\n      /* unroll continuation */\n      status = luaD_rawrunprotected(L, unroll, &status);\n    }\n    if (errorstatus(status)) {  /* unrecoverable error? */\n      L->status = cast_byte(status);  /* mark thread as 'dead' */\n      seterrorobj(L, status, L->top);  /* push error message */\n      L->ci->top = L->top;\n    }\n    else lua_assert(status == L->status);  /* normal end or yield */\n  }\n  L->nny = oldnny;  // \u6062\u590d\u534f\u7a0b\u7684nny\u503c\n  L->nCcalls--;\n  lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));\n  lua_unlock(L);\n  return status;\n}\n")),(0,a.kt)("p",null,"\u53ef\u4ee5\u770b\u51fa\u534f\u7a0b\u7684pcall\u5904\u7406\u6709\u4e9b\u4e0d\u540c\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u8fd9\u6837\uff1f"),(0,a.kt)("p",null,"\u8fd9\u662f\u56e0\u4e3a\u534f\u7a0b\u53ef\u6302\u8d77\uff08yield\uff09\uff0c\u53ef\u6062\u590d\u4e0a\u4e0b\u6587\uff08resume\uff09\uff0c\u5c31\u4f1a\u6709pcall\u6267\u884c\u8fc7\u7a0b\u6709\u534f\u7a0b\u6302\u8d77\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u9700\u8981\u8bb0\u5f55\u8fd8\u539f\u70b9\uff0c\u7136\u540e\u4ece\u4e0a\u4e0b\u6587\u6062\u590d\u3002",(0,a.kt)("br",{parentName:"p"}),"\n","\u6240\u4ee5\u5230\u8fd9\u91cc\u4e5f\u53ef\u4ee5\u53d1\u73b0\uff0c\u9664\u4e86\u521b\u5efa\u7684\u534f\u7a0b\uff0clua state\u539f\u751f\u7684\u534f\u7a0b\u662f\u65e0\u6cd5\u88ab\u6302\u8d77\uff0c\u901a\u5e38\u53ea\u6709\u5728lua\u4ee3\u7801\u6267\u884c\u5b8c\u65f6\u624d\u4f1a\u9000\u51fa\u3002"),(0,a.kt)("p",null,"\u672c\u6587\u8f6c\u81ea ",(0,a.kt)("a",l({parentName:"p"},{href:"https://blog.csdn.net/mycwq/article/details/49256003"}),"https://blog.csdn.net/mycwq/article/details/49256003"),"\uff0c\u5982\u6709\u4fb5\u6743\uff0c\u8bf7\u8054\u7cfb\u5220\u9664\u3002"))}L.isMDXComponent=!0}}]);