"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[96247],{35318:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return g}});var a=r(27378);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var o=a.createContext({}),d=function(e){var t=a.useContext(o),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},p=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=d(r),g=n,k=m["".concat(o,".").concat(g)]||m[g]||u[g]||i;return r?a.createElement(k,l(l({ref:t},p),{},{components:r})):a.createElement(k,l({ref:t},p))}));function g(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,l=new Array(i);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:n,l[1]=s;for(var d=2;d<i;d++)l[d]=r[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},31515:function(e,t,r){r.r(t),r.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return o},toc:function(){return p}});r(27378);var a=r(35318);function n(){return n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(e[a]=r[a])}return e},n.apply(this,arguments)}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}const l={id:"Targeting shader models and GPU features in HLSL",slug:"/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-shader-compile-targets"},s="Targeting shader models and GPU features in HLSL",o={unversionedId:"unity/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/Targeting shader models and GPU features in HLSL",id:"version-Unity@2022.1/unity/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/Targeting shader models and GPU features in HLSL",title:"Targeting shader models and GPU features in HLSL",description:"You can use #pragma directives to indicate that a shader requires certain GPU features. At runtime, Unity uses this information to determine whether a shader program is compatible with the current hardware.",source:"@site/versioned_docs/version-Unity@2022.1/unity/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-shader-compile-targets.md",sourceDirName:"unity/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives",slug:"/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-shader-compile-targets",permalink:"/en/docs/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-shader-compile-targets",editUrl:"https://github.com/danyow/danyow.github.io/edit/main/docs/unity/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-shader-compile-targets.md",tags:[],version:"Unity@2022.1",lastUpdatedBy:"danyow",lastUpdatedAt:1648742180,formattedLastUpdatedAt:"3/31/2022",frontMatter:{id:"Targeting shader models and GPU features in HLSL",slug:"/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-shader-compile-targets"},sidebar:"unity",previous:{title:"Targeting graphics APIs and platforms in HLSL",permalink:"/en/docs/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-shader-compilation-apis"},next:{title:"\u5185\u7f6e\u7740\u8272\u5668 helper \u51fd\u6570",permalink:"/en/docs/graphics/shaders/shader-writing/sl-shader-programs/sl-builtin-functions"}},d={},p=[{value:"Default behavior",id:"default-behavior",level:2},{value:"Special requirements for shader stages",id:"special-requirements-for-shader-stages",level:2},{value:"Specifying GPU features or a shader model",id:"specifying-gpu-features-or-a-shader-model",level:2},{value:"List of \u2018#pragma target\u2019 values",id:"list-of-pragma-target-values",level:2},{value:"List of \u2018#pragma require\u2019 values",id:"list-of-pragma-require-values",level:2}],u={toc:p};function m(e){var{components:t}=e,r=i(e,["components"]);return(0,a.kt)("wrapper",n({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",n({},{id:"targeting-shader-models-and-gpu-features-in-hlsl"}),"Targeting shader models and GPU features in HLSL"),(0,a.kt)("p",null,"You can use ",(0,a.kt)("a",n({parentName:"p"},{href:"/en/docs/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-pragma-directives"}),(0,a.kt)("inlineCode",{parentName:"a"},"#pragma")," directives")," to indicate that a shader requires certain GPU features. At runtime, Unity uses this information to determine whether a shader program is compatible with the current hardware."),(0,a.kt)("p",null,"You can specify individual GPU features with the ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require")," directive, or specify a  ",(0,a.kt)("strong",{parentName:"p"},"shader model"),"  with the ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma target")," directive. A shader model is a shorthand for a group of GPU features; internally, it is the same as a ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require")," directive with the same list of features."),(0,a.kt)("p",null,"It is important to correctly describe the GPU features that your shader requires. If your shader uses features that are not included in the list of requirements, this can result in either compile time errors, or in devices failing to support shaders at runtime."),(0,a.kt)("h2",n({},{id:"default-behavior"}),"Default behavior"),(0,a.kt)("p",null,"By default, Unity compiles shaders with ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require derivatives"),", which corresponds to ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma target 2.5"),"."),(0,a.kt)("h2",n({},{id:"special-requirements-for-shader-stages"}),"Special requirements for shader stages"),(0,a.kt)("p",null,"If your shader defines certain shader stages, Unity automatically adds items to the list of requirements."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If a shader defines a geometry stage (with ",(0,a.kt)("inlineCode",{parentName:"li"},"#pragma geometry"),"), Unity automatically adds ",(0,a.kt)("inlineCode",{parentName:"li"},"geometry")," to the list of requirements."),(0,a.kt)("li",{parentName:"ul"},"If a shader defines a tessellation stage (with ",(0,a.kt)("inlineCode",{parentName:"li"},"#pragma hull")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"#pragma domain"),"), Unity automatically adds ",(0,a.kt)("inlineCode",{parentName:"li"},"tessellation")," to the list of requirements.")),(0,a.kt)("p",null,"If the list of requirements (or the equivalent target value) does not already include these values, Unity displays a warning message when it compiles the shader, to indicate that it has added these requirements. To avoid seeing this warning message, explicitly add the requirements or use an appropriate target value in your code."),(0,a.kt)("h2",n({},{id:"specifying-gpu-features-or-a-shader-model"}),"Specifying GPU features or a shader model"),(0,a.kt)("p",null,"To specify required features, use the ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require")," directive, followed by a list of space-delimited values. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",n({parentName:"pre"},{}),"#pragma require integers mrt8\n")),(0,a.kt)("p",null,"You can also use the ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require")," directive followed by a colon and a list of space-delimited ",(0,a.kt)("a",n({parentName:"p"},{href:"/en/docs/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-multiple-program-variants"}),"shader keywords"),". This means that the requirement applies only to variants that are used when any of the given keywords are enabled."),(0,a.kt)("p",null,"\u4f8b\u5982\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",n({parentName:"pre"},{}),"#pragma require integers mrt8 : EXAMPLE_KEYWORD OTHER_EXAMPLE_KEYWORD\n")),(0,a.kt)("p",null,"You can use multiple ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require")," lines. In this example, the shader requires ",(0,a.kt)("inlineCode",{parentName:"p"},"integers")," in all cases, and ",(0,a.kt)("inlineCode",{parentName:"p"},"mrt8")," if EXAMPLE","_","KEYWORD is enabled."),(0,a.kt)("pre",null,(0,a.kt)("code",n({parentName:"pre"},{}),"#pragma require integers\n#pragma require integers mrt8 : EXAMPLE_KEYWORD\n")),(0,a.kt)("p",null,"To specify a shader model, use ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma target")," directive. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",n({parentName:"pre"},{}),"#pragma target 4.0\n")),(0,a.kt)("p",null,"You can also use the ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma target")," directive followed by a list of space-delimited ",(0,a.kt)("a",n({parentName:"p"},{href:"/en/docs/graphics/shaders/shader-writing/sl-shader-programs/shader-preprocessor-directives/sl-multiple-program-variants"}),"shader keywords"),". This means that the requirement applies only to variants that are used when any of the given keywords are enabled."),(0,a.kt)("p",null,"\u4f8b\u5982\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",n({parentName:"pre"},{}),"#pragma target 4.0 EXAMPLE_KEYWORD OTHER_EXAMPLE_KEYWORD\n")),(0,a.kt)("p",null," ",(0,a.kt)("strong",{parentName:"p"},"Note:"),"  The syntax for specifying keywords for ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma target")," is slightly different. When you specify keywords for ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require"),", you use a colon. When you specify keywords for ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma target"),", you do not use a colon."),(0,a.kt)("h2",n({},{id:"list-of-pragma-target-values"}),"List of \u2018#pragma target\u2019 values"),(0,a.kt)("p",null,"Here is the list of shader models that Unity uses, and the combination of ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require")," values that each corresponds to."),(0,a.kt)("p",null," ",(0,a.kt)("strong",{parentName:"p"},"Note:"),"  Unity\u2019s shader models are similar to DirectX shader models and OpenGL version requirements, but they do not correspond exactly. Read the descriptions carefully to ensure that you understand the differences."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",n({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"\u503c")),(0,a.kt)("th",n({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"\u63cf\u8ff0")),(0,a.kt)("th",n({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"\u652f\u6301")),(0,a.kt)("th",n({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"Equivalent ",(0,a.kt)("inlineCode",{parentName:"strong"},"#pragma require")," values")))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"2.0")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Equivalent to ",(0,a.kt)("a",n({parentName:"td"},{href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-sm2"}),"DirectX shader model 2.0"),".",(0,a.kt)("br",null),(0,a.kt)("br",null),"Limited amount of arithmetic and texture instructions; 8 interpolators; no vertex texture sampling; no derivatives in fragment shaders; no explicit LOD texture sampling."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Works on all platforms supported by Unity."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"\u65e0")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"2.5")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Almost the same as 3.0, but with only 8 interpolators, and no explicit LOD texture sampling."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"DirectX 11 feature level 9+",(0,a.kt)("br",null),"OpenGL 3.2+",(0,a.kt)("br",null),"OpenGL ES 2.0",(0,a.kt)("br",null),"Vulkan",(0,a.kt)("br",null),"Metal"),(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"derivatives"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"3.0")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Equivalent to ",(0,a.kt)("a",n({parentName:"td"},{href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-sm3"}),"DirectX shader model 3.0"),".",(0,a.kt)("br",null),(0,a.kt)("br",null),"."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"DirectX 11 feature level 10 +",(0,a.kt)("br",null),"OpenGL 3.2+",(0,a.kt)("br",null),"OpenGL ES 3.0+",(0,a.kt)("br",null),"Vulkan",(0,a.kt)("br",null),"Metal",(0,a.kt)("br",null),(0,a.kt)("br",null),"Might work on some OpenGL ES 2.0 devices, depending on driver extensions and features."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Everything in ",(0,a.kt)("inlineCode",{parentName:"td"},"2.5"),", plus:",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"interpolators10 samplelod fragcoord"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"3.5")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Equivalent to ",(0,a.kt)("a",n({parentName:"td"},{href:"https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_3.0"}),"OpenGL ES 3.0"),".",(0,a.kt)("br",null),(0,a.kt)("br",null)),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"DirectX 11 feature level 10+",(0,a.kt)("br",null),"OpenGL 3.2+",(0,a.kt)("br",null),"OpenGL ES 3+",(0,a.kt)("br",null),"Vulkan",(0,a.kt)("br",null),"Metal"),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Everything in ",(0,a.kt)("inlineCode",{parentName:"td"},"3.0"),", plus:",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"interpolators15 mrt4 integers 2darray instancing"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"4.0")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Equivalent to ",(0,a.kt)("a",n({parentName:"td"},{href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-sm4"}),"DirectX shader model 4.0"),", but without the requirement to support 8 MRTs."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"DirectX 11 feature level 10+",(0,a.kt)("br",null),"OpenGL 3.2+",(0,a.kt)("br",null),"OpenGL ES 3.1+AEP",(0,a.kt)("br",null),"Vulkan",(0,a.kt)("br",null),"Metal (if no geometry stage is defined)"),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Everything in ",(0,a.kt)("inlineCode",{parentName:"td"},"3.5"),", plus:",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"geometry"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"4.5")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Equivalent to ",(0,a.kt)("a",n({parentName:"td"},{href:"https://en.wikipedia.org/wiki/OpenGL_ES#OpenGL_ES_3.1"}),"OpenGL ES 3.1"),"."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"DirectX 11 feature level 11+",(0,a.kt)("br",null),"OpenGL 4.3+",(0,a.kt)("br",null),"OpenGL ES 3.1",(0,a.kt)("br",null),"Vulkan",(0,a.kt)("br",null),"Metal"),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Everything in ",(0,a.kt)("inlineCode",{parentName:"td"},"3.5"),", plus:",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"compute randomwrite msaatex"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"4.6")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Equivalent to ",(0,a.kt)("a",n({parentName:"td"},{href:"https://en.wikipedia.org/wiki/OpenGL#OpenGL_4.1"}),"OpenGL 4.1"),".",(0,a.kt)("br",null),(0,a.kt)("br",null),"This is the highest OpenGL level supported on a Mac."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"DirectX 11 feature level 11+",(0,a.kt)("br",null),"OpenGL 4.1+",(0,a.kt)("br",null),"OpenGL ES 3.1+AEP",(0,a.kt)("br",null),"Vulkan",(0,a.kt)("br",null),"Metal (if no geometry stage is defined, and no hull or domain stage is defined)"),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Everything in ",(0,a.kt)("inlineCode",{parentName:"td"},"4.0"),", plus:",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"cubearray tesshw tessellation msaatex"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"5.0")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Equivalent to ",(0,a.kt)("a",n({parentName:"td"},{href:"https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/d3d11-graphics-reference-sm5"}),"DirectX shader model 5.0"),", but without the requirement to support 32 interpolators or cubemap arrays."),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"DirectX 11 feature level 11+",(0,a.kt)("br",null),"OpenGL 4.3+",(0,a.kt)("br",null),"OpenGL ES 3.1+AEP",(0,a.kt)("br",null),"Vulkan",(0,a.kt)("br",null),"Metal (if no geometry stage is defined, and no hull or domain stage is defined)"),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Everything in ",(0,a.kt)("inlineCode",{parentName:"td"},"4.0"),", plus:",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"compute randomwrite msaatex tesshw tessellation"))))),(0,a.kt)("p",null,"For information on shader model support for console platforms, see the platform-specific documentation."),(0,a.kt)("p",null," ",(0,a.kt)("strong",{parentName:"p"},"\u6ce8\u610f\uff1a")," "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In the DirectX definitions, shader model 4.0 includes ",(0,a.kt)("inlineCode",{parentName:"li"},"mrt8"),", and shader model 5.0 includes ",(0,a.kt)("inlineCode",{parentName:"li"},"interpolators32")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"cubearray"),". Unity does not include these, for broader compatibility. To require these features, use an explicit ",(0,a.kt)("inlineCode",{parentName:"li"},"#pragma require")," directive."),(0,a.kt)("li",{parentName:"ul"},"If you use a target that requires ",(0,a.kt)("inlineCode",{parentName:"li"},"geometry")," but your shader does not define a geometry stage, Unity removes ",(0,a.kt)("inlineCode",{parentName:"li"},"geometry")," from the list of requirements at compile time."),(0,a.kt)("li",{parentName:"ul"},"If you use a target that requires ",(0,a.kt)("inlineCode",{parentName:"li"},"tessellation")," but your shader does not define a hull or domain stage, Unity removes ",(0,a.kt)("inlineCode",{parentName:"li"},"tessellation")," from the list of requirements at compile time.")),(0,a.kt)("h2",n({},{id:"list-of-pragma-require-values"}),"List of \u2018#pragma require\u2019 values"),(0,a.kt)("p",null,"Here are all the valid values for the ",(0,a.kt)("inlineCode",{parentName:"p"},"#pragma require")," directive."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",n({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"\u503c")),(0,a.kt)("th",n({parentName:"tr"},{align:null}),(0,a.kt)("strong",{parentName:"th"},"\u63cf\u8ff0")))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"interpolators10")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"At least 10 vertex-to-fragment interpolators (\u201cvaryings\u201d) are available.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"interpolators15")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"At least 15 vertex-to-fragment interpolators (\u201cvaryings\u201d) are available.",(0,a.kt)("br",null),(0,a.kt)("br",null)," ",(0,a.kt)("strong",{parentName:"td"},"Note:"),"  Internally, this also automatically adds ",(0,a.kt)("inlineCode",{parentName:"td"},"integers")," to the list of requirements.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"interpolators32")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"At least 32 vertex-to-fragment interpolators (\u201cvaryings\u201d) are available.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"integers")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Integers are a supported data type, including bit/shift operations.",(0,a.kt)("br",null),(0,a.kt)("br",null)," ",(0,a.kt)("strong",{parentName:"td"},"Note:"),"  Internally, this also automatically adds ",(0,a.kt)("inlineCode",{parentName:"td"},"interpolators15")," to the list of requirements.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"mrt4")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"At least 4 render targets are supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"mrt8")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"At least 8 render targets are supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"derivatives")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Pixel shader derivative instructions (ddx/ddy) are supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"samplelod")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Explicit texture LOD sampling (tex2Dlod / SampleLevel) is supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"fragcoord")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Pixel location (XY on screen, ZW depth in clip space) input in pixel shader is supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"2darray")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"2D texture arrays are a supported data type.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"cubearray")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Cubemap arrays are a supported data type.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"instancing")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"SV","_","InstanceID input system value is supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"geometry")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Geometry shader stages are supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"compute")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Compute shaders, structured buffers, and atomic operations are supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"randomwrite")," or ",(0,a.kt)("inlineCode",{parentName:"td"},"uav")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"\u201cRandom write\u201d (UAV) textures are supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"tesshw")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Hardware tessellation is supported, but not necessarily tessellation (hull/domain) shader stages. For example, Metal supports tessellation, but not hull or domain stages.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"tessellation")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Tessellation (hull/domain) shader stages are supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"msaatex")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"The ability to access multi-sampled textures (Texture2DMS in HLSL) is supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"sparsetex")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Sparse textures with residency info (\u201cTier2\u201d support in DirectX terms; ",(0,a.kt)("inlineCode",{parentName:"td"},"CheckAccessFullyMapped")," HLSL function).")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"framebufferfetch")," or ",(0,a.kt)("inlineCode",{parentName:"td"},"fbfetch")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Framebuffer fetch (the ability to read input pixel color in the pixel shader) is supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",n({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"setrtarrayindexfromanyshader")),(0,a.kt)("td",n({parentName:"tr"},{align:null}),"Setting the render target array index from any shader stage (not just the geometry shader stage) is supported.")))))}m.isMDXComponent=!0}}]);