"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[39153],{35318:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return d}});var n=a(27378);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),o=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=o(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),h=o(a),d=i,g=h["".concat(s,".").concat(d)]||h[d]||m[d]||r;return a?n.createElement(g,l(l({ref:t},p),{},{components:a})):n.createElement(g,l({ref:t},p))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,l[1]=c;for(var o=2;o<r;o++)l[o]=a[o];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},66911:function(e,t,a){a.r(t),a.d(t,{assets:function(){return o},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return p}});a(27378);var n=a(35318);function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},i.apply(this,arguments)}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}const l={id:"Dynamic batching",slug:"/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/dynamic-batching"},c="Dynamic batching",s={unversionedId:"unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/Dynamic batching",id:"version-Unity@2022.1/unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/Dynamic batching",title:"Dynamic batching",description:"Dynamic batching is a draw call batching method that batches moving GameObjects to reduce draw calls. Dynamic batching works differently between meshes and geometries that Unity generates dynamically at runtime, such as particle systems. For information about the internal differences between meshes and dynamic geometries, see Dynamic batching for meshes and Dynamic batching for dynamically generated geometries.",source:"@site/versioned_docs/version-Unity@2022.1/unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/dynamic-batching.md",sourceDirName:"unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching",slug:"/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/dynamic-batching",permalink:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/dynamic-batching",editUrl:"https://github.com/danyow/danyow.github.io/edit/main/docs/unity/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/dynamic-batching.md",tags:[],version:"Unity@2022.1",lastUpdatedBy:"danyow",lastUpdatedAt:1648742180,formattedLastUpdatedAt:"3/31/2022",frontMatter:{id:"Dynamic batching",slug:"/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/dynamic-batching"},sidebar:"unity",previous:{title:"Draw call batching",permalink:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/draw-call-batching"},next:{title:"Static batching",permalink:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/static-batching"}},o={},p=[{value:"Requirements and compatibility",id:"requirements-and-compatibility",level:2},{value:"Render pipeline compatibility",id:"render-pipeline-compatibility",level:3},{value:"Using dynamic batching",id:"using-dynamic-batching",level:2},{value:"Dynamic batching for meshes",id:"dynamic-batching-for-meshes",level:2},{value:"\u9650\u5236",id:"\u9650\u5236",level:3},{value:"Dynamic batching for dynamically generated geometries",id:"dynamic-batching-for-dynamically-generated-geometries",level:2}],m={toc:p};function h(e){var{components:t}=e,a=r(e,["components"]);return(0,n.kt)("wrapper",i({},m,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",i({},{id:"dynamic-batching"}),"Dynamic batching"),(0,n.kt)("p",null,"Dynamic batching is a ",(0,n.kt)("a",i({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/draw-call-batching"}),"draw call batching")," method that batches moving GameObjects to reduce ",(0,n.kt)("a",i({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/optimizing-draw-calls"}),"draw calls"),". Dynamic batching works differently between meshes and geometries that Unity generates dynamically at runtime, such as ",(0,n.kt)("a",i({parentName:"p"},{href:"/en/docs/graphics/visual-effects/particle-systems/particle-systems"}),"particle systems"),". For information about the internal differences between meshes and dynamic geometries, see ",(0,n.kt)("a",i({parentName:"p"},{href:"#dynamic-batching-for-meshes"}),"Dynamic batching for meshes")," and ",(0,n.kt)("a",i({parentName:"p"},{href:"#dynamic-batching-for-dynamically-generated-geometries"}),"Dynamic batching for dynamically generated geometries"),"."),(0,n.kt)("p",null," ",(0,n.kt)("strong",{parentName:"p"},"Note")," : Dynamic batching for meshes was designed to optimize performance on old low-end devices. On modern consumer hardware, the work dynamic batching does on the CPU can be greater than the overhead of a draw call. This negatively affects performance. For more information, see ",(0,n.kt)("a",i({parentName:"p"},{href:"#dynamic-batching-for-meshes"}),"Dynamic batching for meshes"),"."),(0,n.kt)("h2",i({},{id:"requirements-and-compatibility"}),"Requirements and compatibility"),(0,n.kt)("p",null,"This section includes information about the render pipeline compatibility of dynamic batching."),(0,n.kt)("h3",i({},{id:"render-pipeline-compatibility"}),"Render pipeline compatibility"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"\u529f\u80fd")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"\u5185\u7f6e\u6e32\u67d3\u7ba1\u7ebf")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"\u901a\u7528\u6e32\u67d3\u7ba1\u7ebf (URP)")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"\u9ad8\u6e05\u6e32\u67d3\u7ba1\u7ebf (HDRP)")),(0,n.kt)("th",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"th"},"Custom Scriptable Render Pipeline (SRP)")))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",i({parentName:"tr"},{align:null}),(0,n.kt)("strong",{parentName:"td"},"Dynamic Batching")),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"\u662f"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"\u662f"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"\u5426"),(0,n.kt)("td",i({parentName:"tr"},{align:null}),"\u662f")))),(0,n.kt)("h2",i({},{id:"using-dynamic-batching"}),"Using dynamic batching"),(0,n.kt)("p",null,"Unity always uses dynamic batching for dynamic geometry such as Particle Systems"),(0,n.kt)("p",null,"To use dynamic batching for meshes:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Go to  ",(0,n.kt)("strong",{parentName:"li"},"Edit"),"  ",">","  ",(0,n.kt)("strong",{parentName:"li"},"Project Settings"),"  ",">","  ",(0,n.kt)("strong",{parentName:"li"},"Player")," ."),(0,n.kt)("li",{parentName:"ol"},"In  ",(0,n.kt)("strong",{parentName:"li"},"Other Settings")," , enable  ",(0,n.kt)("strong",{parentName:"li"},"Dynamic Batching")," .")),(0,n.kt)("p",null,"Unity automatically batches moving meshes into the same draw call if they fulfill the criteria described in the ",(0,n.kt)("a",i({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/draw-call-batching#using-draw-call-batching"}),"common usage information"),"."),(0,n.kt)("h2",i({},{id:"dynamic-batching-for-meshes"}),"Dynamic batching for meshes"),(0,n.kt)("p",null,"Dynamic batching for meshes works by transforming all vertices into world space. on the CPU, rather than on the GPU. This means dynamic batching is only an optimization if the transformation work is less resource intensive than doing a draw call."),(0,n.kt)("p",null,"The resource requirements of a draw call depend on many factors, primarily the graphics API. For example, on consoles or modern APIs like Apple Metal, the draw call overhead is generally much lower, and often dynamic batching doesn\u2019t produce a gain in performance. To determine whether it\u2019s beneficial to use dynamic batching in your application, ",(0,n.kt)("a",i({parentName:"p"},{href:"/en/docs/unity-overview/analysis/profiler/profiler"}),"profile")," your application with and without dynamic batching."),(0,n.kt)("p",null,"Unity can use dynamic batching for shadows casters, even if their materials are different, as long as the material values Unity needs for the shadow pass are the same. For example, multiple crates can use materials that have different textures. Although the material assets are different, the difference is irrelevant for the shadow caster pass and Unity can batch shadows for the crate GameObjects in the shadow render step."),(0,n.kt)("h3",i({},{id:"\u9650\u5236"}),"\u9650\u5236"),(0,n.kt)("p",null,"In the following scenarios, Unity either can\u2019t use dynamic batching at all or can only apply dynamic batching to a limited extent:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Unity can\u2019t apply dynamic batching to meshes that contain more than 900 vertex attributes and 300 vertices. This is because dynamic batching for meshes has an overhead per vertex. For example, if your shader uses vertex position, vertex normal, and a single UV, then Unity can batch up to 300 vertices. However, if your shader uses vertex position, vertex normal, UV0, UV1, and vertex tangent, then Unity can only batch 180 vertices."),(0,n.kt)("li",{parentName:"ul"},"If GameObjects use different material instances, Unity can\u2019t batch them together, even if they are essentially the same. The only exception to this is shadow caster rendering."),(0,n.kt)("li",{parentName:"ul"},"GameObjects with lightmaps have additional renderer parameters. This means that, if you want to batch lightmapped GameObjects, they must point to the same lightmap location."),(0,n.kt)("li",{parentName:"ul"},"Unity can\u2019t fully apply dynamic batching to GameObjects that use multi-pass shaders.",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Almost all Unity shaders support several lights in forward rendering. To achieve this, they process an additional render pass for each light. Unity only batches the first render pass. It can\u2019t batch the draw calls for the additional per-pixel lights."),(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("a",i({parentName:"li"},{href:"/en/docs/graphics/render-pipelines/built-in-render-pipeline/rendering-paths/rendering-paths"}),"Legacy Deferred rendering path")," doesn\u2019t support dynamic batching because it draws GameObjects in two render passes. The first pass is a light pre-pass and the second pass renders the GameObjects.")))),(0,n.kt)("h2",i({},{id:"dynamic-batching-for-dynamically-generated-geometries"}),"Dynamic batching for dynamically generated geometries"),(0,n.kt)("p",null,"The following renderers dynamically generate geometries, such as particles and lines, that you can optimize using dynamic batching:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"/en/docs/graphics/visual-effects/particle-systems/built-in-particle-system/built-in-particle-system"}),"Built-in Particle Systems")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"/en/docs/graphics/visual-effects/visual-effects-lines-trails-billboards/class-line-renderer"}),"Line Renderers")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",i({parentName:"li"},{href:"/en/docs/graphics/visual-effects/visual-effects-lines-trails-billboards/class-trail-renderer"}),"Trail Renderers"))),(0,n.kt)("p",null,"Dynamic batching for dynamically generated geometries works differently than it does for meshes:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"For each renderer, Unity builds all dynamically batchable content into one large vertex buffer."),(0,n.kt)("li",{parentName:"ol"},"The renderer sets up the material state for the batch."),(0,n.kt)("li",{parentName:"ol"},"Unity then binds the vertex buffer to the GPU."),(0,n.kt)("li",{parentName:"ol"},"For each Renderer in the batch, Unity updates the offset in the vertex buffer and submits a new draw call.")),(0,n.kt)("p",null,"This approach is similar to how Unity submits draw calls for ",(0,n.kt)("a",i({parentName:"p"},{href:"/en/docs/graphics/graphics-performance-profiling/optimizing-draw-calls/draw-call-batching/static-batching"}),"static batching"),"."))}h.isMDXComponent=!0}}]);