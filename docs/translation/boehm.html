<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-translation/boehm">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.18">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Danyow RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Danyow Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="Danyow JSON Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-141789564-1"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-141789564-1",{})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Danyow" href="/opensearch.xml">
<link rel="alternate" type="application/rss+xml" href="/changelog/rss.xml" title="日志 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/changelog/atom.xml" title="日志 Atom Feed">
<link rel="alternate" type="application/json" href="/changelog/feed.json" title="日志 JSON Feed">
<link rel="icon" href="/img/logo.png">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="rgb(37, 194, 160)">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#000">
<link rel="apple-touch-icon" href="/img/logo.png">
<link rel="mask-icon" href="/img/logo.png" color="rgb(62, 204, 94)">
<meta name="msapplication-TileImage" content="/img/logo.png">
<meta name="msapplication-TileColor" content="#000">
<link rel="stylesheet" href="/katex/katex.min.css"><title data-rh="true">Boehm垃圾回收 | Danyow</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://danyow.github.io/docs/translation/boehm"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Boehm垃圾回收 | Danyow"><meta data-rh="true" name="description" content="Slide幻灯片地址"><meta data-rh="true" property="og:description" content="Slide幻灯片地址"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://danyow.github.io/docs/translation/boehm"><link data-rh="true" rel="alternate" href="https://danyow.github.io/docs/translation/boehm" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://danyow.github.io/en/docs/translation/boehm" hreflang="en"><link data-rh="true" rel="alternate" href="https://danyow.github.io/docs/translation/boehm" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://S3KRFC060Q-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.bff76bc0.css">
<link rel="preload" href="/assets/js/runtime~main.143b31b0.js" as="script">
<link rel="preload" href="/assets/js/main.cabcfe72.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,t("light"))}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_BxGa">跳到主要内容</a></div><div class="announcementBar_yyVl" role="banner"><div class="announcementBarPlaceholder_Il1w"></div><div class="announcementBarContent_KFU1">⭐️ <a target="_blank" rel="noopener noreferrer" href="https://github.com/danyow/danyow.github.io">如喜, 赏星</a>  ⭐️</div><button type="button" class="clean-btn close announcementBarClose_axA0" aria-label="关闭"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav class="navbar navbar--fixed-top navbarHideable_FcXi"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Danyow Logo" class="themedImage_aIr_ themedImage--light_DGIu" height="32" width="32"><img src="/img/logo-dark.svg" alt="Danyow Logo" class="themedImage_aIr_ themedImage--dark_RoHN" height="32" width="32"></div><b class="navbar__title">Danyow</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs">储备</a><a class="navbar__item navbar__link" href="/blog">博客</a><a class="navbar__item navbar__link" href="/changelog">日志</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" href="/docs">v0 🚧</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/translation/boehm">v0 🚧</a></li><li><a href="https://danyow-jbufheovr-danyow.vercel.app/docs/unity-manual/unity-manual" target="_blank" rel="noopener noreferrer" class="dropdown__link">Unity@2022.1<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_GWqj"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://danyow-n1bljgzah-danyow.vercel.app/docs/lua/hello" target="_blank" rel="noopener noreferrer" class="dropdown__link">Lua@5.3<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_GWqj"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a class="dropdown__link" href="/versions">所有版本</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><span><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_NpMu"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg><span>中文</span></span></a><ul class="dropdown__menu"><li><a href="/docs/translation/boehm" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active">中文</a></li><li><a href="/en/docs/translation/boehm" target="_self" rel="noopener noreferrer" class="dropdown__link">English</a></li><li><a href="https://github.com/danyow/danyow.github.io/issues/3526" target="_blank" rel="noopener noreferrer" class="dropdown__link">Help Us Translate<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_GWqj"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><a href="https://github.com/danyow/danyow.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_IT2h colorModeToggle_o_qc"><button class="clean-btn toggleButton_pGki toggleButtonDisabled_vZLo" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_dYsV"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_WRF1"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_lGmL"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="docPage_zNSk"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_ecpa" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_NEdF"><div class="sidebar_Uz2u sidebarWithHideableNavbar_MFe1"><a tabindex="-1" class="sidebarLogo_iqfm" href="/"><img src="/img/logo.svg" alt="Danyow Logo" class="themedImage_aIr_ themedImage--light_DGIu" height="32" width="32"><img src="/img/logo-dark.svg" alt="Danyow Logo" class="themedImage_aIr_ themedImage--dark_RoHN" height="32" width="32"><b>Danyow</b></a><nav class="menu thin-scrollbar menu_XU2j menuWithAnnouncementBar_vo3y"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/audition">八股</a><button aria-label="打开/收起侧边栏菜单「八股」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/glossary">术语表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs">占位符</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/reprint">转载</a><button aria-label="打开/收起侧边栏菜单「转载」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/translation">翻译</a><button aria-label="打开/收起侧边栏菜单「翻译」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/translation/boehm">Boehm垃圾回收</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/translation/luagc">Lua的垃圾回收</a></li></ul></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_Essf"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_bqna"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_vJqy"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_ygLL"><div class="docItemContainer_yJzi"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_nmcO" aria-label="breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/">🏠</a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/translation"><span itemprop="name">翻译</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="item name">Boehm垃圾回收</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_aX8Q theme-doc-toc-mobile tocMobile_By44"><button type="button" class="clean-btn tocCollapsibleButton_Va7b">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>The &quot;Boehm-Demers-Weiser&quot; Conservative Garbage Collector</h1><blockquote><p><a href="https://www.hboehm.info/gc/04tutorial.pdf" target="_blank" rel="noopener noreferrer">Slide幻灯片地址</a></p></blockquote><blockquote><p><a href="https://dl.acm.org/doi/pdf/10.1145/96709.96735" target="_blank" rel="noopener noreferrer">论文地址</a></p></blockquote><blockquote><p><a href="https://www.hboehm.info/" target="_blank" rel="noopener noreferrer">大佬主页</a></p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="outline">Outline<a class="hash-link" href="#outline" title="标题的直接链接">​</a></h2><ul><li>Introduction<ul><li>Interface</li><li>Implementation basics &amp; goals</li></ul></li><li>Implementation details and issues<ul><li>Core collector</li><li>Enhancements</li></ul></li><li>Experiences and a few measurements</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="概述">概述<a class="hash-link" href="#概述" title="标题的直接链接">​</a></h3><ul><li>导言<ul><li>接口</li><li>实现基础与目标</li></ul></li><li>实现细节和问题<ul><li>核心回收器</li><li>增强功能</li></ul></li><li>经验和一些测试</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="what-is-it">What is it?<a class="hash-link" href="#what-is-it" title="标题的直接链接">​</a></h2><ul><li>A garbage collecting replacement for C&#x27;s malloc().<ul><li>Calls to free() are optional.</li><li>Unreachable memory is automatically reclaimed, and made available to future
malloc() calls.</li></ul></li><li>A tracing (mark/sweep) garbage collector.<ul><li>It periodically determines which objects can be reached by following pointers.</li><li>The rest can be reused for other purposes.</li></ul></li><li>An easy way to add garbage collection to a runtime system.<ul><li>Easy to interface to.</li><li>Interacts well with C/C++ code.</li><li>Gcj (Java), Mono (C#, .NET), Bigloo (Scheme), MzScheme.</li></ul></li><li>A leak detector for programs that call free().<ul><li>Unreachable unfreed memory is a memory leak.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="他是什么">他是什么？<a class="hash-link" href="#他是什么" title="标题的直接链接">​</a></h3><ul><li>一个可以替代<code>C</code>中<code>malloc()</code>的垃圾回收器。<ul><li>对<code>free()</code>的调用是可选的。</li><li>不可达内存会自动回收，并提供特性 <code>malloc()</code>用以调用。</li></ul></li><li>一个跟踪（<code>Marks&amp;Weep</code>）垃圾回收器。<ul><li>它定期确定可以通过跟随指针判断哪些对象可达。</li><li>也可以用于其他目的。</li></ul></li><li>一个简单的方法将该垃圾回收加入到运行时系统.<ul><li>易于接口。</li><li>与<code>C/C++</code>代码交互良好。</li><li><code>GCJ（Java）</code>、<code>Mono（C#, .NET）</code>、<code>Bigloo（Scheme）</code>、<code>MzScheme</code>。</li></ul></li><li>用于调用 <code>free()</code> 的程序的泄漏检测器。<ul><li>不可达的并且未释放内存是内存泄漏。</li></ul></li></ul><p><code>GCJ</code> = <code>GNU Compiler for the Java Programing Language</code>(GNU Java语言编译器)</p><ul><li><code>Java</code>源文件 -&gt; <code>Java</code>字节码文件</li><li><code>Java</code>源文件 -&gt; <code>Java</code>本地机器码</li><li><code>Java</code>字节码文件 -&gt; <code>Java</code>本地机器码</li></ul><p><code>Bigloo</code>: <code>Bigloo是一个高效的Scheme语言编程环境</code></p><p>通过将 <code>Scheme</code> 转成 <code>C</code> 语言来优化编译，<code>Bigloo</code> 允许在 <code>Scheme</code> 和 <code>C</code> 语言间进行连接。</p><p><code>MzScheme</code>: <code>MzScheme是一个高效的Scheme语言编程环境</code>  </p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="example-lisp-s-expressions">Example: Lisp S-expressions<a class="hash-link" href="#example-lisp-s-expressions" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_CBWl language-c theme-code-block"><div class="codeBlockContent_vhl8" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-c codeBlock_w2AC thin-scrollbar"><code class="codeBlockLines_OfWd"><span class="token-line" style="color:#393A34"><span class="token macro property directive-hash" style="color:#005CC5">#</span><span class="token macro property directive keyword" style="color:#CF222E">include</span><span class="token macro property" style="color:#005CC5"> </span><span class="token macro property string" style="color:#E3116C">&quot;gc.h&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#CF222E">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#CF222E">union</span><span class="token plain"> se </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#CF222E">struct</span><span class="token plain"> </span><span class="token class-name" style="color:#116329">cons</span><span class="token plain"> </span><span class="token operator" style="color:#D73A49">*</span><span class="token plain"> cp</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#CF222E">int</span><span class="token plain"> i</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> sexpr</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#CF222E">struct</span><span class="token plain"> </span><span class="token class-name" style="color:#116329">cons</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#CF222E">union</span><span class="token plain"> se head</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#CF222E">union</span><span class="token plain"> se tail</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#005CC5">#</span><span class="token macro property directive keyword" style="color:#CF222E">define</span><span class="token macro property" style="color:#005CC5"> </span><span class="token macro property macro-name function" style="color:#8250DF">car</span><span class="token macro property expression punctuation" style="color:#393A34">(</span><span class="token macro property expression" style="color:#005CC5">s</span><span class="token macro property expression punctuation" style="color:#393A34">)</span><span class="token macro property expression" style="color:#005CC5"> </span><span class="token macro property expression punctuation" style="color:#393A34">(</span><span class="token macro property expression" style="color:#005CC5">s</span><span class="token macro property expression punctuation" style="color:#393A34">)</span><span class="token macro property expression punctuation" style="color:#393A34">.</span><span class="token macro property expression" style="color:#005CC5">cp</span><span class="token macro property expression operator" style="color:#D73A49">-&gt;</span><span class="token macro property expression" style="color:#005CC5">head</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#005CC5">#</span><span class="token macro property directive keyword" style="color:#CF222E">define</span><span class="token macro property" style="color:#005CC5"> </span><span class="token macro property macro-name function" style="color:#8250DF">cdr</span><span class="token macro property expression punctuation" style="color:#393A34">(</span><span class="token macro property expression" style="color:#005CC5">s</span><span class="token macro property expression punctuation" style="color:#393A34">)</span><span class="token macro property expression" style="color:#005CC5"> </span><span class="token macro property expression punctuation" style="color:#393A34">(</span><span class="token macro property expression" style="color:#005CC5">s</span><span class="token macro property expression punctuation" style="color:#393A34">)</span><span class="token macro property expression punctuation" style="color:#393A34">.</span><span class="token macro property expression" style="color:#005CC5">cp</span><span class="token macro property expression operator" style="color:#D73A49">-&gt;</span><span class="token macro property expression" style="color:#005CC5">tail</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#005CC5">#</span><span class="token macro property directive keyword" style="color:#CF222E">define</span><span class="token macro property" style="color:#005CC5"> </span><span class="token macro property macro-name function" style="color:#8250DF">from_i</span><span class="token macro property expression punctuation" style="color:#393A34">(</span><span class="token macro property expression" style="color:#005CC5">z</span><span class="token macro property expression punctuation" style="color:#393A34">)</span><span class="token macro property expression" style="color:#005CC5"> </span><span class="token macro property expression punctuation" style="color:#393A34">(</span><span class="token macro property expression punctuation" style="color:#393A34">{</span><span class="token macro property expression" style="color:#005CC5">sexpr tmp</span><span class="token macro property expression punctuation" style="color:#393A34">;</span><span class="token macro property expression" style="color:#005CC5"> tmp</span><span class="token macro property expression punctuation" style="color:#393A34">.</span><span class="token macro property expression" style="color:#005CC5">i</span><span class="token macro property expression operator" style="color:#D73A49">=</span><span class="token macro property expression" style="color:#005CC5">z</span><span class="token macro property expression punctuation" style="color:#393A34">;</span><span class="token macro property expression" style="color:#005CC5"> tmp</span><span class="token macro property expression punctuation" style="color:#393A34">;</span><span class="token macro property expression punctuation" style="color:#393A34">}</span><span class="token macro property expression punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#005CC5">#</span><span class="token macro property directive keyword" style="color:#CF222E">define</span><span class="token macro property" style="color:#005CC5"> </span><span class="token macro property macro-name function" style="color:#8250DF">to_i</span><span class="token macro property expression punctuation" style="color:#393A34">(</span><span class="token macro property expression" style="color:#005CC5">s</span><span class="token macro property expression punctuation" style="color:#393A34">)</span><span class="token macro property expression" style="color:#005CC5"> </span><span class="token macro property expression punctuation" style="color:#393A34">(</span><span class="token macro property expression" style="color:#005CC5">s</span><span class="token macro property expression punctuation" style="color:#393A34">)</span><span class="token macro property expression punctuation" style="color:#393A34">.</span><span class="token macro property expression" style="color:#005CC5">i</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sexpr </span><span class="token function" style="color:#8250DF">cons</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sexpr a</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> sexpr b</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  sexpr tmp </span><span class="token operator" style="color:#D73A49">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token function" style="color:#8250DF">GC_MALLOC</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#CF222E">sizeof</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#CF222E">struct</span><span class="token plain"> </span><span class="token class-name" style="color:#116329">cons</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function" style="color:#8250DF">car</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">tmp</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#D73A49">=</span><span class="token plain"> a</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token function" style="color:#8250DF">cdr</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">tmp</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#D73A49">=</span><span class="token plain"> b</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#CF222E">return</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">tmp</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#CF222E">int</span><span class="token plain"> </span><span class="token function" style="color:#8250DF">main</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#CF222E">return</span><span class="token plain"> </span><span class="token function" style="color:#8250DF">to_i</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#8250DF">car</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#8250DF">cons</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#8250DF">from_i</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#005CC5">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token function" style="color:#8250DF">from_i</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#005CC5">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_R7VQ clean-btn"><span class="copyButtonIcons_Uqyx" aria-hidden="true"><svg class="copyButtonIcon_CtfL" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_Mq1p" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="示例lisp-s-expressions">示例：<code>Lisp S-expressions</code><a class="hash-link" href="#示例lisp-s-expressions" title="标题的直接链接">​</a></h3><p>替换 <code>malloc()</code> 为 <code>GC_MALLOC()</code>?</p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="where-did-it-come-from">Where did it come from?<a class="hash-link" href="#where-did-it-come-from" title="标题的直接链接">​</a></h2><ul><li>Began life (ca. 1980) as a simple GC for the Russell programming language. (
Demers was original author.)</li><li>Later (ca. 1985?) changed to remove restrictions on generated code, and allow
use in the compiler itself.<ul><li>Eliminate endless debugging of manual reference counting.</li></ul></li><li>Used for student compilers for a language with higher-order functions.</li><li>Mark Weiser explored use as leak detector (ca. 1986).</li><li>A variant served as the Xerox Cedar GC from the late 80s, replacing
reference-count collector.</li><li>Unrelated to an earlier garbage collector for C written by Doug McIlroy and
apparently layered on top of malloc.</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="它是从哪里来的">它是从哪里来的？<a class="hash-link" href="#它是从哪里来的" title="标题的直接链接">​</a></h3><ul><li>作为 <code>Russell</code> 编程语言的简单 <code>GC</code> 开始生活（约 1980 年）。（德默斯是原作者。）</li><li>后来（大约 1985 年？）更改为删除对生成代码的限制，并允许在编译器本身中使用。<ul><li>消除手动引用计数的无休止调试。</li></ul></li><li>用于具有高阶函数的语言的学生编译器。</li><li><code>Mark Weiser</code> 探索了用作检漏仪的用途（约 1986 年）。</li><li>80 年代后期的 <code>Xerox Cedar GC</code> 变体取代了引用计数收集器。</li><li>与 <code>Doug McIlroy</code> 为 <code>C</code> 编写的早期垃圾收集器无关，并且显然位于 <code>malloc</code> 之上。</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="what-else-can-it-do">What else can it do?<a class="hash-link" href="#what-else-can-it-do" title="标题的直接链接">​</a></h2><ul><li>20 years of creeping features, including:<ul><li>Invoking finalizers after an object becomes unreachable.</li><li>Support for use in runtime systems.<ul><li>If the compiler wants to help, it can.</li></ul></li><li>Support for heap debugging.<ul><li>What&#x27;s in the heap?</li><li>Why is it still there? How can it still be referenced?</li></ul></li><li>Support for threads and multiprocessor GC.<ul><li>Maybe a way to speed up standard C applications on multiprocessors?</li></ul></li><li>Various mechanisms for reducing GC pauses:<ul><li>Incremental (but not hard real-time) GC.</li><li>Generational GC which concentrates effort on young objects.
(But objects are not moved.)</li><li>Abortable collections.</li></ul></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="它还能做什么">它还能做什么？<a class="hash-link" href="#它还能做什么" title="标题的直接链接">​</a></h3><ul><li>20年来的缓慢支持，包括：<ul><li>在对象变得不可达后调用终结器。</li><li>支持在运行时系统中使用。<ul><li>如果编译器也需要帮助，它可以做到。</li></ul></li><li>支持 堆 调试。<ul><li>堆 里有什么？</li><li>为什么它还在那里？它怎么还能被引用？</li></ul></li><li>支持线程和多处理器<code>GC</code>。<ul><li>也许是一种能在多处理器上加速标准<code>C</code>应用程序的新方式？</li></ul></li><li>减少<code>GC</code>暂停的各种机制：<ul><li>增量（但不是硬实时）<code>GC</code>。</li><li>将精力集中在年轻对象上的分代 <code>GC</code>.(但是对象并不会移动.)</li><li>可中止回收过程。</li></ul></li></ul></li></ul><p>这里说明了, 该算法并不打算把对象拷贝来拷贝去的.</p><p>对于机身性能还没溢出的产品上, 使用该<code>GC</code>算法, 可以说是一个比较好的方案了.</p><p>比如手机.</p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="what-cant-it-do">What can&#x27;t it do?<a class="hash-link" href="#what-cant-it-do" title="标题的直接链接">​</a></h2><ul><li>Reclaim memory or invoke finalizers/destructors immediately.<ul><li>Like all tracing garbage collectors, it only checks for unreachable memory occasionally. </li><li>And synchronous heap finalizers are broken anyway...</li></ul></li><li>Reclaim all unreachable objects.<ul><li>Generally a few will still have pointers to them stored somewhere.</li><li>The GC doesn&#x27;t know which registers will be referenced. </li><li>And there are other issues ...</li><li>And unreachable isn&#x27;t well-defined anyway ...</li><li>But we generally avoid growing leaks.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="它不能做什么">它不能做什么?<a class="hash-link" href="#它不能做什么" title="标题的直接链接">​</a></h3><ul><li>立即回收内存或调用终结器/析构函数。<ul><li>与所有跟踪垃圾收集器一样，它只是偶尔检查不可达内存.</li><li>无论如何, 同步堆终结器都被破坏了...</li></ul></li><li>回收所有所有不可达对象。<ul><li>一般来说，一些人仍然会在某处存储指向它们的指针。</li><li><code>GC</code>不知道将引用哪些寄存器。</li><li>还有其他问题...</li><li>不可达其实也是不很明确的定义...</li><li>但我们通常会避免越来越多的泄漏。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="dealing-with-c-conservative-garbage-collection">Dealing with C: Conservative Garbage Collection<a class="hash-link" href="#dealing-with-c-conservative-garbage-collection" title="标题的直接链接">​</a></h2><ul><li>For C/C++ programs, we may not know where the pointer variables (roots) are.<ul><li>We may want to use a standard compiler. (Slightly risky with optimization, but popular.)</li><li>Program may use C unions.</li></ul></li><li>Even layout of heap objects may be unknown.</li><li>It&#x27;s easier to build a Java/Scheme/ML/... compiler if pointer location information is optional.</li><li><strong>Conservative collectors handle pointer location uncertainty:</strong><ul><li><strong><em>If it might be a pointer it&#x27;s treated as a pointer.</em></strong></li><li><strong>Objects with ambiguous references are not moved.</strong><ul><li><strong>And we never move any objects.</strong></li></ul></li><li><strong>May lead to accidental retention of garbage objects.</strong></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="与c打交道保守的垃圾收集">与<code>C</code>打交道：保守的垃圾收集<a class="hash-link" href="#与c打交道保守的垃圾收集" title="标题的直接链接">​</a></h3><ul><li>对于<code>C/C++</code>程序，我们可能不知道指针变量（<code>root set</code>）在哪里。<ul><li>我们可能需要使用标准编译器。（优化有点风险，但是很受欢迎。）</li><li>程序可以使用<code>C</code>的<code>union</code>(联合)。</li></ul></li><li>甚至堆对象的布局也可能是未知的。</li><li>如果指针位置信息是可选的。那么构建<code>Java/Scheme/ML...</code>编译器就会更容易.</li><li><strong>保守收集器处理指针位置不确定性：</strong><ul><li><strong><em>如果它可能是一个指针，则将其视为指针。</em></strong></li><li><strong>不移动具有不明确引用的对象。</strong><ul><li><strong>毕竟, 我们从不移动任何物体。</strong></li></ul></li><li><strong>可能会导致垃圾对象的意外保留。</strong></li></ul></li></ul><blockquote><p>引用 <a href="https://www.bilibili.com/video/BV1r44y1z7X3?p=2&amp;t=38m56s" target="_blank" rel="noopener noreferrer">高川老师</a> 演讲时候的话, </p></blockquote><p>在保守内存回收器来看，当回收一个内存块的时候，会尝试找到内存块下边所有的指针指向的地址，并且标记为引用。比如说 <code>Object a</code> 引用了 <code>Object b</code> ，当 <code>Object a</code> 不能回收的时候，会同时标记 <code>Object b</code> 也不能被回收。</p><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220410092737.png" class="img_PFMr"></p><ul><li>如何知道这个东西是一个数还是一个指针的？</li><li>靠猜!</li></ul><p>这有一个 <code>potential pointer</code>潜在指针，并不知道它是不是真的指针，而以一个 <code>pattern</code> 的方式来检查当前这个数有没有可能是一个指针。</p><p>比如说第一个指针，检查<code>0x011</code>这个数值所指向的地址里边有没有东西，若有就标记成 1 ，这次不回收。<code>0x012</code> 指向了 <code>Object c</code>， <code>Object c</code> 和 <code>Object a</code> 没有应用依赖关系，但是它恰好分配到了这块内存上。</p><p>对于贝母来说，指的这块地方，有东西不回收。<code>0x013</code> 指向了一块没用的内存。</p><p>贝母垃圾回收会把这个地址加到黑名单里。当下次进行大内存分配的时候，刚好踩到了这个地址的时候，贝母会告诉你这块内存不能用，贝母把它先留下了，你再去分配一块。</p><p>这就是非精准，对于要回收的内存，它可能收不回来，对于没用的内存，它也可能不让用。</p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="c-interface-overview">C Interface overview<a class="hash-link" href="#c-interface-overview" title="标题的直接链接">​</a></h2><p>Debugging support: GC_xyz() vs. GC_XYZ() functions:</p><ul><li>GC_xyz() is the real function.</li><li>GC_XYZ(x) expands to either <code>GC_xyx(x)</code> or <code>GC_debug_xyz(x, &lt;source position, etc&gt;)</code>.</li><li>Clients should:<ul><li>Use the all-caps version.</li><li>Always include gc.h.</li><li>Define GC_DEBUG before including gc.h for debugging.</li></ul></li><li>This is becoming obsolete technology.<ul><li>Requires too much recompilation.</li><li>Libunwind, addr2line allow better alternatives.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="c接口概述"><code>C</code>接口概述<a class="hash-link" href="#c接口概述" title="标题的直接链接">​</a></h3><p>调试支持：<code>GC_xyz()</code> vs. <code>GC_XYZ()</code>:</p><ul><li><code>GC_xyz()</code> 是真正的函数.</li><li><code>GC_XYZ(x)</code> 展开为 <code>GC_xyx(x)</code> or <code>GC_debug_xyz(x, &lt;source position, etc&gt;)</code></li><li>客户端应该:<ul><li>使用全大写版本。</li><li>始终包括 <code>gc.h</code></li><li>在包含<code>gc.h</code>进行调试之前定义<code>GC_DEBUG</code>。</li></ul></li><li>这正在成为过时的技术。<ul><li>需要太多的重新编译。</li><li><code>Libunwind</code>、<code>addr2line</code> 允许更好的选择。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="c-interface-main-functions">C interface, main functions<a class="hash-link" href="#c-interface-main-functions" title="标题的直接链接">​</a></h2><ul><li>GC_MALLOC(bytes)<ul><li>In simple cases, this is enough.</li></ul></li><li>GC_MALLOC_ATOMIC(bytes)<ul><li>Allocate pointer-free or untraced (but collected) memory.</li></ul></li><li>GC_MALLOC_UNCOLLECTABLE(bytes)<ul><li>Allocate uncollectable (but traced) memory.</li></ul></li><li>GC_REALLOC(p, bytes)</li><li>GC_REGISTER_FINALIZER(...)<ul><li>Register (or unregister or retrieve) &quot;finalizer&quot; code to be called when an
object is otherwise &quot;unreachable&quot;. </li><li>Unlike Java, by default, an object is reachable if it can be referenced from other finalizers. (Also Java variant.)</li></ul></li><li>GC_INIT()  Optional on most platforms. (Must be called from main program on a
few.)</li><li>GC_FREE()  If you insist. (Usually helps performance for large objects, hurts
for small ones.)</li><li>GC_MALLOC_IGNORE_OFF_PAGE()  Like GC_MALLOC(), but for large arrays with
pointers to (near) the beginning.</li><li>Plus statistics, control of incremental GC, more allocator variants, heap
limits, GC frequency controls, fast inline allocators, etc.</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="c-接口-主要的一些方法"><code>C</code> 接口, 主要的一些方法:<a class="hash-link" href="#c-接口-主要的一些方法" title="标题的直接链接">​</a></h3><ul><li><code>GC_MALLOC(bytes)</code><ul><li>在简单的情况下，这就足够了。</li></ul></li><li><code>GC_MALLOC_ATOMIC(bytes)</code><ul><li>分配无指针或未跟踪（但已回收过）内存。</li></ul></li><li><code>GC_MALLOC_UNCOLLECTABLE(bytes)</code><ul><li>分配无法回收的（但已跟踪）的内存。</li></ul></li><li><code>GC_REALLOC(p, bytes)</code></li><li><code>GC_REGISTER_FINALIZER(...)</code><ul><li>注册（或注销或检索）&quot;终结器&quot;代码以在对象&quot;不可达&quot;时调用。</li><li>与 <code>Java</code> 不同，默认情况下，如果可以从其他终结器引用对象，则该对象是可访问的。（ <code>Java</code> 变体也是。）</li></ul></li><li><code>GC_INIT() </code><ul><li>在大多数平台上都是可选的。 (必须在少数情况下从主程序调用。)</li></ul></li><li><code>GC_FREE()</code>  <ul><li>如果你坚持. (通常对大对象有帮助，对小对象有伤害.)</li></ul></li><li><code>GC_MALLOC_IGNORE_OFF_PAGE()</code> <ul><li>与<code>GC_MALLOC()</code>类似, 但用于指针指向（接近）开头的大型数组。</li></ul></li><li>加上统计数据、增量<code>GC</code>控制、更多分配器变量、堆限制、<code>GC</code>频率控制、快速内联分配器等。</li></ul><hr><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="c-interface">C++ interface<a class="hash-link" href="#c-interface" title="标题的直接链接">​</a></h2><ul><li>&quot;gc_cpp.h&quot; provides a base class gc:<ul><li>Overrides new to be GC_MALLOC for subclasses of gc. </li><li>Overrides ::new to be GC_MALLOC_UNCOLLECTABLE. </li><li>Provide gc_cleanup class which registers destructor as finalizer. </li><li>Built by Detlefs, Hull, based on Ellis, Detlefs work. </li><li>...</li></ul></li><li>&quot;gc_allocator.h&quot; defines STL allocators:<ul><li>gc_allocator </li><li>traceable_allocator</li></ul></li><li>Particularly gc_cpp.h is annoyingly brittle.<ul><li>Perhaps more so than some of the gross hacks we&#x27;ll hint at later.</li><li>Replacing global operator new seems problematic for many compilers.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="c接口"><code>C++</code>接口<a class="hash-link" href="#c接口" title="标题的直接链接">​</a></h3><ul><li>&quot;<code>gc_cpp.h</code>&quot;提供了一个基类<code>gc</code>：<ul><li>为 <code>gc</code> 的子类覆盖 <code>new</code> 为 <code>GC_MALLOC</code>。</li><li>将 <code>::new</code> 覆盖为 <code>GC_MALLOC_UNCOLLECTABLE</code>。</li><li>提供将析构函数注册为终结器的 <code>gc_cleanup</code> 类。</li><li><code>Detlefs</code> 由赫尔的 <code>Detlefs</code> 建造，基于 <code>Ellis</code>，<code>Detlefs</code> 工作。</li><li>...</li></ul></li><li>&quot;<code>gc_allocator.h</code>&quot;定义<code>STL</code>分配器：<ul><li><code>gc_allocator</code></li><li><code>traceable_allocator</code>(可追踪分配器)</li></ul></li><li>尤其是<code>gc_cpp.h</code>非常脆弱。<ul><li>也许比我们稍后会暗示的一些严重的黑客攻击更重要。</li><li>对许多编译器来说，替换全局运算符<code>new</code>似乎有问题。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="environment-variables">Environment variables<a class="hash-link" href="#environment-variables" title="标题的直接链接">​</a></h2><ul><li>Collector can be influenced by various environment variables:<ul><li>GC_INITIAL_HEAP_SIZE</li><li>GC_MAXIMUM_HEAP_SIZE</li><li>GC_PRINT_STATS</li><li>GC_DUMP_REGULARLY</li><li>GC_ENABLE_INCREMENTAL (caution!)</li><li>GC_PAUSE_TIME_TARGET</li><li>GC_DON&#x27;T_GC</li><li>GC_IGNORE_GCJ_INFO ignore compiler-provided pointer location information.</li><li>GC_MARKERS Set the number of GC threads (where supported).</li><li>...</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="环境变量">环境变量<a class="hash-link" href="#环境变量" title="标题的直接链接">​</a></h3><ul><li>回收器可能会受到各种环境变量的影响:<ul><li><code>GC_INITIAL_HEAP_SIZE</code></li><li><code>GC_MAXIMUM_HEAP_SIZE</code></li><li><code>GC_PRINT_STATS</code></li><li><code>GC_DUMP_REGULARLY</code></li><li><code>GC_ENABLE_INCREMENTAL</code> (小心使用!)</li><li><code>GC_PAUSE_TIME_TARGET</code></li><li><code>GC_DON&#x27;T_GC</code></li><li><code>GC_IGNORE_GCJ_INFO</code> <ul><li>忽略编译器提供的指针位置信息。</li></ul></li><li><code>GC_MARKERS</code> <ul><li>设置<code>GC</code>线程的数量（如果支持）。</li></ul></li><li>...</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="how-does-it-work">How does it work?<a class="hash-link" href="#how-does-it-work" title="标题的直接链接">​</a></h2><p>Occasionally (when we run out of memory?):</p><ul><li>Mark all objects referenced directly by pointer variables (roots)</li><li>Repeatedly:<ul><li>Mark objects directly reachable from newly marked objects.</li></ul></li><li>Finally identify unmarked objects (sweep)<ul><li>E.g. put them in free lists.</li><li>Reuse to satisfy allocation requests.</li></ul></li><li><strong>Objects are not moved.</strong></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="它是如何工作的">它是如何工作的？<a class="hash-link" href="#它是如何工作的" title="标题的直接链接">​</a></h3><p>偶尔（当我们用完内存时？）：</p><ul><li>标记指针变量(<code>roots set</code>)能直接引用到的所有对象</li><li>重复地：<ul><li>标记可从新标记的对象直接可达的对象。</li></ul></li><li>最后识别未标记的对象（清除）<ul><li>例如: 把他们放在<code>free list</code>上。</li><li>重用以满足分配内存请求。</li></ul></li><li><strong>对象不会移动。</strong></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="marksweep-illustration">Mark/sweep illustration<a class="hash-link" href="#marksweep-illustration" title="标题的直接链接">​</a></h2><ul><li><p>第一步(标记):
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409213248.png" class="img_PFMr"></p></li><li><p>第二部(清除)
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409213447.png" class="img_PFMr"></p></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="标记清除-插画">标记/清除 插画<a class="hash-link" href="#标记清除-插画" title="标题的直接链接">​</a></h3><p>从<code>Stack</code>(根)出发, 依次标记(绿色对勾)标记可达的 堆 的内存空间. 然后&quot;清除&quot;未被标记的.</p><p>从图示来理解:
这里这个清除其实蛮简单的, 只是单纯放到一个 <code>free list</code> 里面, 等要有需要的时候被重新分配.</p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="easy-performance-issue">Easy performance issue<a class="hash-link" href="#easy-performance-issue" title="标题的直接链接">​</a></h2><ol><li></li></ol><ul><li>If heap is nearly full, we collect too frequently.<ul><li>May collect once per allocation. </li><li>We look at all reachable objects each time -&gt; expensive</li></ul></li><li>Solution:<ul><li>Always make sure that heap is e.g. 1.5 times larger than necessary.</li><li>Each cycle, allocate n/3 bytes, trace 2n/3 bytes.</li><li>Trace 2 bytes per byte allocated.
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/live-data.png" class="img_PFMr"></li></ul></li></ul><ol start="2"><li></li></ol><ul><li>Performance is often dominated by memory accesses.</li><li>Each reclaimed object is touched twice per cycle.<ul><li>Once during sweep phase.</li><li>Once during allocation.</li></ul></li><li>Solution:<ul><li>Sweep a little bit at a time before allocation.</li><li>Try to keep object in cache.</li><li>&quot;Sweep phase&quot; is a misnomer.</li><li>Imposes constraints on GC data structure.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="简单性能问题">简单性能问题<a class="hash-link" href="#简单性能问题" title="标题的直接链接">​</a></h3><ol><li></li></ol><ul><li>如果堆快满了，我们就回收地更频繁。<ul><li>每次分配可回收一次。</li><li>我们每次都会查看所有可达的对象 -&gt; 昂贵</li></ul></li><li>解决方案：<ul><li>始终确保 堆 比需要的大1.5倍。</li><li>每个周期，分配 <code>n/3</code> 字节时，跟踪 <code>2n/3</code> 字节。</li><li>在分配到的内存空间里跟踪前2个字节。
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/live-data.png" class="img_PFMr"></li></ul></li></ul><ol start="2"><li></li></ol><ul><li>性能通常由内存访问决定。</li><li>每个回收的对象每个周期被触摸两次。<ul><li>一次在清除阶段。</li><li>一次在分配过程中。</li></ul></li><li>解决方案：<ul><li>分配前一次清除一点。</li><li>尝试将对象保留在缓存中。</li><li>&quot;清除阶段&quot;用词不当。</li><li>对<code>GC</code>数据结构施加约束。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="asymptotic-complexity-of-marksweep-vs-copying">Asymptotic Complexity of MarkSweep vs. Copying<a class="hash-link" href="#asymptotic-complexity-of-marksweep-vs-copying" title="标题的直接链接">​</a></h2><ul><li>Conventional view:<ul><li>Copying: O(live_data_size)</li><li>M/S:<ul><li>Mark: O(live_data_size)</li><li>Sweep: O(heap_size)</li><li>Total: O(heap_size)</li></ul></li><li>M/S more expensive (if heap_size &gt;&gt; live_data_size)</li></ul></li><li>Alternate view:<ul><li>Sweep doesn&#x27;t count; part of allocation.</li><li>M/S can avoid touching pointer-free data (strings, bitmaps)</li><li>M/S: O(pointer_containing_data)</li><li>Copying more expensive<ul><li>(if pointer_containing_data &lt;&lt; live_data_size)</li></ul></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="运行时间复杂度-ms-vs-copying分析">运行时间复杂度 <code>M&amp;S</code> vs <code>Copying</code>分析.<a class="hash-link" href="#运行时间复杂度-ms-vs-copying分析" title="标题的直接链接">​</a></h3><ul><li>传统观点：<ul><li><code>Copying</code> ：<code>O(live_data_size)</code></li><li><code>M&amp;S</code>:<ul><li>标记: <code>O(live_data_size)</code></li><li>扫描: <code>O(heap_size)</code></li><li>总计: <code>O(heap_size)</code></li></ul></li><li><code>M&amp;S</code> 复杂度更高当（<code>heap_size</code> &gt;&gt; <code>live_data_size)</code></li></ul></li><li>另一种观点：<ul><li>清除不算数分配的一部分。</li><li><code>M&amp;S</code>可以避免接触无指针数据（字符串、位图）</li><li><code>M&amp;S</code>: <code>O(pointer_containing_data)</code></li><li><code>Copying</code> 复杂度更高当<ul><li>（如果 <code>pointer_containing_data</code> &lt;&lt; <code>live_data_size</code> ）</li></ul></li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="implementation-details-overview">Implementation details overview<a class="hash-link" href="#implementation-details-overview" title="标题的直接链接">​</a></h2><ul><li>General design issues:<ul><li>The underlying allocator.</li><li><strong>Pointer validity checks and mark bits.</strong></li><li>Partial pointer location information.</li><li><strong>Locating potential roots.</strong></li><li>Mark algorithm and stack overflow.</li><li>Thread support.</li></ul></li><li>Enhancements:<ul><li><strong>Black-listing of &quot;false pointers&quot;</strong></li><li>Incremental/Concurrent/Generational GC.</li><li>Parallel marking.</li><li>Thread-local allocation.</li><li>Finalization.</li><li>Debug support.</li></ul></li></ul><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200001.png" class="img_PFMr"></p><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="实现细节描述">实现细节描述<a class="hash-link" href="#实现细节描述" title="标题的直接链接">​</a></h3><ul><li>一般设计问题：<ul><li>底层分配器。</li><li><strong>指针有效性检查并标记位。</strong></li><li>部分指针位置信息。</li><li><strong>寻找潜在的根<code>roots set</code>。</strong></li><li>标记算法和堆栈溢出。</li><li>线程支持。</li></ul></li><li>增强功能：<ul><li><strong>&quot;错误指针&quot;黑名单</strong></li><li>增量/并发/分代<code>GC</code>。</li><li>平行标记。</li><li>线程本地分配。</li><li>终结。</li><li>调试支持。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="allocator-design">Allocator design<a class="hash-link" href="#allocator-design" title="标题的直接链接">​</a></h2><ul><li>Segregate objects by size, pointer contents...</li><li>Each &quot;page&quot; contains objects of a single size.</li><li>Separate free lists for each small object size.</li><li>Large object allocator for pages, large objects.</li><li><strong>Characteristics:</strong><ul><li><strong>No per object space overhead (except mark bits)</strong></li><li><strong>Small object fragmentation overhead factor:</strong><ul><li><strong>&lt; #size classes = O(log(largest_sz/smallest_sz))</strong></li><li><strong>Asymptotically optimal (Robson 71)</strong></li></ul></li><li><strong>Fast allocation.</strong></li><li><strong>Partial sweeps are possible.</strong></li><li><strong>Can avoid touching pointer-free pages.</strong></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="分配器设计">分配器设计<a class="hash-link" href="#分配器设计" title="标题的直接链接">​</a></h3><ul><li>按大小、指针内容分隔对象...</li><li>每个<code>&quot;page&quot;</code>包含单个大小的对象。</li><li>每个小对象大小都有单独地<code>free list</code>。</li><li>用于<code>page</code>、大对象的大对象分配器。</li><li><strong>特点</strong>：<ul><li><strong>无每对象空间开销（标记位除外）</strong></li><li><strong>小对象碎片开销系数：</strong><ul><li><strong><code>O(log(largest_sz/smallest_sz))</code></strong></li><li><strong>渐近最优（<code>Robson 71</code>）</strong></li></ul></li><li><strong>快速分配</strong>。</li><li><strong>部分扫描是可能的。</strong></li><li><strong>可以避免触摸无指针<code>page</code>。</strong></li></ul></li></ul><p><a href="https://www.bilibili.com/video/BV1r44y1z7X3?p=2&amp;t=35m05s" target="_blank" rel="noopener noreferrer">高川老师讲贝母的内存设计</a></p><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220410094632.png" class="img_PFMr"></p><p>贝母在内存管理的时候，是一个两级的管理：第一级，Kind类型，贝母在分配的时候会分配出很多种不同的类型。</p><p>常见的有 <code>PTRFREE</code>（无指针类型），<code>Normal</code>（比较一般的类型），还有 <code>Uncollectable</code>（不可回收类型），一般是贝母自己要用的一块内存会分配到 <code>Uncollectable</code>。</p><p>每一个类型是一个列表，在列表下面分别会挂一个二级列表，去标明当前这一块内存块下面的大小，在第二层的下面挂着一个链表，这个链表里边每一块就是对应上面大小的一小块内存。</p><p>图中两个 <code>Block0</code> 是物理连接的，这两块物理地址是连续的，假如现在要回收两个 <code>Block0</code> ，当这两块内存都被释放掉的时候，<code>Unity</code>会尝试去找两块，比如说释放第一块，<code>Unity</code>发现后边的物理内存也是被释放掉的。</p><p>便把两块合并起来，让指针直接挂到更大的地方去，从而尽量减少整体内存碎片的发生。这个策略能理解为尽量会把空闲出来的内存合并成一个较大的内存块，同时在以移动指针的方式。</p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="heap-layout">Heap layout<a class="hash-link" href="#heap-layout" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200042.png" class="img_PFMr"></p><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="堆布局">堆布局<a class="hash-link" href="#堆布局" title="标题的直接链接">​</a></h3><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="meta-data">Meta-data<a class="hash-link" href="#meta-data" title="标题的直接链接">​</a></h2><ul><li>Need mark bit for each object.</li><li>Information for pointer validity &amp; object size, etc.</li><li>Support discontiguous heaps</li><li>Options for mark bits:<ul><li><em>In object:</em><ul><li><em>Objects: must be aligned.</em></li><li><em>Stealing a bit may require a word.</em> </li></ul></li><li><em>At beginning of each block:</em><ul><li><em>All mark bits are mapped to few cache lines.</em></li><li><em>Must touch pages with pointer-free objects.</em></li></ul></li><li>In separate data structure.<ul><li>More instructions for each access.</li><li>Pointer-free pages are not touched, fewer cache issues.</li></ul></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="元数据">元数据<a class="hash-link" href="#元数据" title="标题的直接链接">​</a></h3><ul><li>每个对象都需要标记位。</li><li>指针有效性和对象大小等信息。</li><li>支持不连续堆</li><li>标记位的选项：<ul><li><em>在对象中：</em><ul><li><em>对象：必须对齐。</em></li><li><em>窃取一个字节可能需要一个单词。</em></li></ul></li><li><em>在每个块的开头：</em><ul><li><em>所有标记位都映射到几个高速缓存行。</em></li><li><em>必须使用无指针对象触摸<code>page</code>。</em></li></ul></li><li>在单独的数据结构中。<ul><li>每次访问都有更多说明。</li><li>无指针<code>page</code>不会被触碰，缓存问题更少。</li></ul></li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="meta-data-lookup">Meta-data lookup<a class="hash-link" href="#meta-data-lookup" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200112.png" class="img_PFMr"></p><ul><li><code>Page descriptor</code>: 页面描述符</li><li><code>Mark bits</code>: 标记位</li><li><code>Offset Map(later)</code>: 偏移表（延迟） </li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="pointer-validity-check">Pointer validity check<a class="hash-link" href="#pointer-validity-check" title="标题的直接链接">​</a></h2><ul><li>Get page descriptor. Valid heap page?<ul><li>About three memory references.<ul><li>Simple top level hashing scheme for 64-bit addresses.</li></ul></li><li>Two with a small cache.</li></ul></li><li>If not first page of object, adjust.</li><li>Valid offset in valid object?<ul><li>Remainder computation on offset in page gives object start.</li><li>Remainder can be looked up in table of &quot;valid offsets&quot;.</li><li>Allows pointers to only certain offsets in object to be considered valid. Check is constant time.</li><li>Small constant number of memory references.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="指针有效性检查">指针有效性检查<a class="hash-link" href="#指针有效性检查" title="标题的直接链接">​</a></h3><ul><li>获取页面描述符。有效的堆<code>page</code>？<ul><li>大约三次内存引用。<ul><li>64位地址只是一个简单顶层哈希方案。</li></ul></li><li>两个带有小缓存。</li></ul></li><li>如果不是对象的第一<code>page</code>，请调整。</li><li>有效对象中的有效偏移量？<ul><li>页中偏移量的余数计算使对象开始。</li><li>剩余部分可在&quot;有效偏移&quot;表中查找。</li><li>只允许指向对象中某些偏移量的指针被视为有效。检查是固定时间。</li><li>少量恒定数量的内存引用。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="partial-pointer-location-type-information">Partial pointer location (type) information.<a class="hash-link" href="#partial-pointer-location-type-information" title="标题的直接链接">​</a></h2><ul><li>It&#x27;s often easy to determine location of pointers in heap objects (e.g. gcj (Java), Mono (.Net)).</li><li>Collector provides different allocation calls to communicate this.</li><li>Objects are segregated both by size and kind.</li><li>Each kind has associated object descriptor:<ul><li>First n fields are pointers.</li><li>30- or 62-bit bitmap identifies pointer locations.</li><li>Client specified mark procedure.</li><li>Indirect: descriptor is in object or vtable.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="部分指针位置类型信息">部分指针位置（类型）信息。<a class="hash-link" href="#部分指针位置类型信息" title="标题的直接链接">​</a></h3><ul><li>确定堆对象中指针的位置通常很容易（例如<code>GCJ（Java）</code>、<code>Mono（.Net）</code>）。</li><li>回收器提供不同的分配调用来进行通信。</li><li>对象是按大小和种类分开的。</li><li>每种类型都有关联的对象描述符：<ul><li>前 <code>n</code> 个字段是指针。</li><li>30位或62位位图标识指针位置。</li><li>客户指定的标记程序。</li><li>间接：描述符位于对象或<code>vtable</code>中。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="locating-roots">Locating roots<a class="hash-link" href="#locating-roots" title="标题的直接链接">​</a></h2><ul><li>By default roots consist of:<ul><li>Registers</li><li>Runtime stack(s)</li><li>Statically allocated data regions<ul><li>Main program + dynamic libraries</li></ul></li></ul></li><li><strong>How do we get their contents/location?</strong><ul><li><strong>Registers: abuse setjmp, __builtin_unwind_init, ...</strong></li><li><strong>Runtime stack(s): you don&#x27;t really want to know.</strong><ul><li><strong>Need consistent caller-save reg. snapshot</strong></li></ul></li><li><strong>Static data segments: you don&#x27;t want to know that either.</strong></li><li><strong>Very platform dependent</strong><ul><li><strong>But you only have to do it once per platform.</strong></li></ul></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="定位根">定位根<a class="hash-link" href="#定位根" title="标题的直接链接">​</a></h3><ul><li>默认情况下，根<code>roots set</code>包括：<ul><li>寄存器</li><li>运行时栈</li><li>静态分配的数据区域<ul><li>主程序 + 动态库</li></ul></li></ul></li><li><strong>我们如何得到他们的位置？</strong><ul><li><strong>寄存器：滥用<code>setjmp</code> <code>__builtin_unwind_init</code>...</strong></li><li><strong>运行时栈：你并不想知道。</strong><ul><li><strong>需要一个固定的调用者来保存<code>reg.</code>快照</strong></li></ul></li><li><strong>静态数据段：你也不想知道。</strong></li><li><strong>非常依赖平台</strong><ul><li><strong>但每个平台您只需执行一次。</strong></li></ul></li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="basic-mark-algorithm">Basic mark algorithm<a class="hash-link" href="#basic-mark-algorithm" title="标题的直接链接">​</a></h2><ul><li>Maintain explicit mark stack of pairs:
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200205.png" class="img_PFMr"></li><li>Initially:<ul><li>For each individual root, push object.</li><li>For each root range, push range.</li></ul></li><li>Then repeatedly:<ul><li>Pop (addr, descr) pair from stack.</li><li>For each possible pointer in memory described by pair:<ul><li>Check pointer validity. If valid and unmarked:</li><li>Set mark bit for target. (Already have page descriptor.)</li><li>Push object address and descriptor (from page descriptor)</li></ul></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="基本标记算法">基本标记算法<a class="hash-link" href="#基本标记算法" title="标题的直接链接">​</a></h3><ul><li>维护显式标记栈对(<code>key</code>, <code>value</code>)：
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200205.png" class="img_PFMr"></li><li>最初：<ul><li>对于每个单独的根(<code>roots set</code>)，推入对象。</li><li>对于每个根范围，推入整个根范围。</li></ul></li><li>然后反复说：<ul><li>从栈中弹出（<code>addr</code>，<code>descr</code>）对。</li><li>对于由 <code>pair</code> 描述的内存中每个可能的指针：<ul><li>检查指针的有效性。如果有效且未标记：</li><li>为目标设置标记位。（已经有页面描述符。）</li><li>推入对象地址和描述符（从页面描述符）</li></ul></li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="marker-refinements">Marker refinements<a class="hash-link" href="#marker-refinements" title="标题的直接链接">​</a></h2><ul><li>Tune as much as possible.<ul><li>This is where the GC spends its time.</li></ul></li><li>It&#x27;s the memory accesses that matter.<ul><li>Prefetch object as we push its descriptor on stack.</li><li>May save 1/3 of mark time.</li></ul></li><li>Range check possible pointers for plausibility first.<ul><li>Eliminates almost all non-pointers.</li></ul></li><li>Minor benefit from keeping cache of recently looked up block descriptors.<ul><li>Probably more important for 64 bit platforms.</li><li>But uncached lookup is already fast.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="标记改进">标记改进<a class="hash-link" href="#标记改进" title="标题的直接链接">​</a></h3><ul><li>尽量调。<ul><li>这是<code>GC</code>花费时间的地方。</li></ul></li><li>重要的是内存访问。<ul><li>当我们将其描述符压入堆时预取对象。</li><li>可以节省 1/3 个标记时间。</li></ul></li><li>范围首先检查可能的指针的合理性。<ul><li>消除了几乎所有的非指针。</li></ul></li><li>保留最近查找的块描述符的缓存带来的小好处。<ul><li>对于64位平台可能更重要。</li><li>但无缓存查找已经很快了。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="the-marker-core-version-pre-70">The marker core (version pre-7.0)<a class="hash-link" href="#the-marker-core-version-pre-70" title="标题的直接链接">​</a></h2><ol><li>Retrieve mark descriptor from stack.</li><li>(Possibly retrieve &quot;indirect&quot; descriptor from object.)</li><li>Look for pointers in object satisfying range check. Immediately prefetch at that address.</li><li>For each likely nested pointer, processing first one last:<ul><li>Look up header in cache (2 memory references).</li><li>Get offset from beginning of block.</li><li>Divide by object size to get object start, and displacement in object.</li><li>If displacement is nonzero, check table for validity.</li><li>Check mark bit in header.</li><li>If not set, set it, get descriptor from block header, push entry on mark stack.</li></ul></li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="标记器核心70之前的版本">标记器核心（7.0之前的版本）<a class="hash-link" href="#标记器核心70之前的版本" title="标题的直接链接">​</a></h3><ol><li>从栈中检索标记描述符。</li><li>（可能从对象中检索&quot;间接&quot;描述符。）</li><li>在满足范围检查的对象中寻找指针。立即预取该地址。</li><li>对于每个可能的嵌套指针，最后处理第一个：<ul><li>在缓存中查找标头（2个内存引用）。</li><li>从块的开头获得偏移量。</li><li>除以对象大小以获得对象开始和对象中的位移。</li><li>如果位移不为零，检查表的有效性。</li><li>检查头部的标记位。</li><li>如果未设置，则设置它，从块头获取描述符，将条目推入标记栈上。</li></ul></li></ol><p>这里很大一个篇幅在描写栈. 但描述的是标记器</p><p>以下是分配器的相关描述, 合并参考:</p><p><a href="https://www.bilibili.com/video/BV1r44y1z7X3?p=2&amp;t=13m25s" target="_blank" rel="noopener noreferrer">高川老师讲栈分配器</a></p><p>栈分配器有三个特点:</p><ul><li>第一个是特别地快，</li><li>第二个是特别地小，</li><li>第三个是临时，</li></ul><p>分配器大部分情况下是用来分配临时变量。</p><p>当要去分配一块内存的时候，实际上 <code>Unity</code> 帮忙分配了两块内存。</p><ul><li>第一块是<code>header</code>，记录了当前这一次分配的一些信息。比如：某一块当前是不是要被删掉，是不是还在用；真正给用户的区域大小；比如说当前块的前面一块是谁。</li><li><code>Header</code>下面才是第二块，即用户的分配使用区域。这一整块内存是在一开始就已经预先分配好的，在进行栈分配的时候，只是在不停的调整栈顶指针，依次向下分配，每一次只在栈的顶端，也就是这块内存的尾部再去分配。</li></ul><p>当整个预先分配栈内存被消耗干净了之后，还会额外的拓展出一块新的，这个拓展不是无限的而是有一个大小的限制。</p><p>在回收内存时，首先把这块内存的 <code>deleted</code> 的在 <code>Header</code> 里边标记成1，表示这一块内存已经无用了，再栈顶指针回弹就可以了，这样是非常快的。分配和回收一样都是挪栈指针，所以分配和回收都非常地快。</p><p>如果回收的位置是中间而不是内存块的尾巴，只需要把头的这个 <code>deleted</code> 的标记成1，也就是标记上已经删除了，直到尾巴被回收，在栈顶指针回弹的时候，会去再检查当前这一块是不是也被删除了，</p><p>如果是，栈顶指针再次向上移动，直到找到一个没有被删除的块，或者是挪到了 <code>Header</code>，这样就导致如果尾巴处的内存一直没有释放，中间已经释放的内存块无法再次使用，这就是栈分配器的一个限制，它无法快速立刻去重用已经释放的内存，它必须要等栈顶被释放的时候，才能向回去寻找这些连续内存。</p><blockquote><p>当因为你的数据量太大，把拥挤的临时堆栈撑爆了，有两种方法解决：</p></blockquote><ol><li>去减少你们每一帧的数据量。</li><li>通过Unity源码，把堆栈加大一点。</li></ol><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="marker-performance-why-gc-needs-a-fast-multiplier">Marker performance: Why GC needs a fast multiplier.<a class="hash-link" href="#marker-performance-why-gc-needs-a-fast-multiplier" title="标题的直接链接">​</a></h2><ul><li><strong>On toy benchmark, small objects., 1x1.4GHz Itanium</strong><ul><li><strong>500MB/sec (Peak mem. Bandwidth 6.4GB/sec.)</strong></li><li><strong>About 90 cycles/object. (L3 cache miss ~200cycles)</strong></li></ul></li><li><strong>About 260MB/sec, 180 cycles/object on a 2GHz Xeon.</strong></li><li>Cache misses matter a lot.</li><li>Divisions are a problem.<ul><li>Can easily multiply by reciprocal.</li><li>Integer multiply has around 15 cycles latency on IA64.<ul><li>Similar on Pentium 4?</li></ul></li><li>Very hard to hide latency.</li><li>Table lookup of remainder, mark bit per allocation granule (not object)
wins (~20% on P4 Xeon).</li></ul></li><li>Could we do multiple header lookups &amp; divisions at once to hide latency? Maybe</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="标记器性能为什么-gc-需要快速乘法器">标记器性能：为什么 <code>GC</code> 需要快速乘法器<a class="hash-link" href="#标记器性能为什么-gc-需要快速乘法器" title="标题的直接链接">​</a></h3><ul><li><strong>在玩具基准测试中，小对象，<code>1x1.4GHz</code> 安腾</strong><ul><li><strong><code>500MB/s</code>（峰值内存。带宽 <code>6.4GB/s</code>。）</strong></li><li><strong>大约 90 个周期/对象。（<code>L3</code> 缓存未命中 <code>~200cycles</code>）</strong></li></ul></li><li><strong>在 <code>2GHz Xeon</code> 上大约 <code>260MB/s</code>，180 个周期/对象。</strong></li><li>缓存未命中很重要。</li><li>分工是个问题。<ul><li>可以很容易地乘以倒数。</li><li>整数乘法在 <code>IA64</code> 上有大约 15 个周期的延迟。<ul><li><code>Pentium 4</code> 类似吗？</li></ul></li><li>很难隐藏延迟。</li><li>余数的表查找，每个分配颗粒（非对象）的标记位获胜（在 <code>P4 Xeon</code> 上约为 20%）。</li></ul></li><li>我们可以一次进行多个标头查找和划分以隐藏延迟吗？也许</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="what-if-the-mark-stack-overflows">What if the mark stack overflows?<a class="hash-link" href="#what-if-the-mark-stack-overflows" title="标题的直接链接">​</a></h2><ul><li><strong>Likely as you approach memory limit.</strong></li><li><strong>Programmers expect to be able to recover from running out-of-memory</strong> <ul><li><strong>... although it is almost never 100% reliable, GC or not.</strong></li></ul></li><li>We<ul><li>Drop part of stack.</li><li>Set overflowed flag.</li></ul></li><li>If flag is set at end of mark phase:<ul><li>Rescan heap. Look for marked -&gt; unmarked pointers.</li><li>Mark again from such targets.</li><li>Repeat if necessary.</li><li>Grow mark stack if possible.</li></ul></li><li>Never push large number of entries without setting a mark bit.<ul><li>Ensures forward progress.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="如果标记堆栈溢出">如果标记堆栈溢出<a class="hash-link" href="#如果标记堆栈溢出" title="标题的直接链接">​</a></h3><ul><li><strong>可能当您接近内存限制时。</strong></li><li><strong>程序员希望能够从内存不足中恢复</strong><ul><li><strong>……尽管它几乎从来都不是 100% 可靠的，不管 <code>GC</code> 与否。</strong></li></ul></li><li>我们<ul><li>删除堆栈的一部分。</li><li>设置溢出标志。</li></ul></li><li>如果在标记阶段结束时设置了标志：<ul><li>重新扫描堆。寻找标记 -&gt; 未标记的指针。</li><li>从这些目标再次标记。</li><li>必要时重复。</li><li>如果可能，增加标记堆栈。</li></ul></li><li>切勿在未设置标记位的情况下推送大量条目。<ul><li>确保前进。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="the-sweep-phase">The &quot;sweep phase&quot;<a class="hash-link" href="#the-sweep-phase" title="标题的直接链接">​</a></h2><ul><li>Sweep large objects and completely empty pages eagerly.</li><li>Completely empty pages are easily detectable and surprisingly common.<ul><li>Effectively coalesces some small objects very cheaply.</li></ul></li><li>Sweep small object pages when we encounter an empty free list.</li><li>Separate pages can be swept in parallel.</li><li>Empirically, execution time is almost always dominated by marker.</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="清除阶段">清除阶段<a class="hash-link" href="#清除阶段" title="标题的直接链接">​</a></h3><ul><li>急切地扫描大对象和完全清空页面。</li><li>完全空白的页面很容易被检测到并且非常普遍。<ul><li>非常便宜地有效地合并一些小对象。</li></ul></li><li>当我们遇到一个空的空闲列表时，扫描小对象页面。</li><li>可以并行扫描单独的页面。</li><li>根据经验，执行时间几乎总是由标记支配。</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="thread-support">Thread support<a class="hash-link" href="#thread-support" title="标题的直接链接">​</a></h2><ul><li>Uncontrolled concurrent mutation of data structures can cause objects to be overlooked by marker:
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200333.png" class="img_PFMr"></li><li>Results in reclaimed reachable objects.</li><li>We stop threads during critical GC phases.<ul><li>Unlike most GCs, threads can be
stopped anywhere.</li></ul></li><li>On most platforms, we send each thread a signal, with handshake in handler.<ul><li>Ensures that thread is stopped.</li><li>Pushes register contents onto the (GC-visible) stack.</li></ul></li><li>Typically requires that thread creation calls be intercepted by GC.<ul><li>GC substitutes its own thread start routine.</li><li>Keeps track of threads, shadowing thread library.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="线程支持">线程支持<a class="hash-link" href="#线程支持" title="标题的直接链接">​</a></h3><ul><li>数据结构的不受控制的并发突变会导致对象被标记忽略：
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200333.png" class="img_PFMr"></li><li>导致回收的可达对象</li><li>我们在关键的 <code>GC</code> 阶段停止线程。<ul><li>与大多数 <code>GC</code> 不同，线程可以在任何地方停止。</li></ul></li><li>在大多数平台上，我们向每个线程发送一个信号，并在处理程序中进行握手。<ul><li>确保线程停止。</li><li>将寄存器内容推送到（<code>GC</code> 可见的）堆栈上。</li></ul></li><li>通常要求 <code>GC</code> 拦截线程创建调用。<ul><li><code>GC</code> 替换它自己的线程启动例程。</li><li>跟踪线程，隐藏线程库。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="enhancement-1-black-listing">Enhancement 1: Black-listing<a class="hash-link" href="#enhancement-1-black-listing" title="标题的直接链接">​</a></h2><ul><li>Conservative pointer-finding can cause memory retention:
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200419.png" class="img_PFMr"></li><li>In many cases, this is avoidable.<ul><li>If we see an address near future heap growth:
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200457.png" class="img_PFMr"></li><li>Don&#x27;t allocate at location 0x1a34c. </li><li>We track pages with bogus pointers to them.<ul><li>Marker updates list.</li><li>Allocate at most small pointer-free objects there.</li></ul></li></ul></li></ul><h3></h3><ul><li>保守的指针查找会导致内存保留：
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200419.png" class="img_PFMr"></li><li>在许多情况下，这是可以避免的。<ul><li>如果我们在不久的将来看到一个地址堆增长：
<img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200457.png" class="img_PFMr"></li><li>不要在位置 <code>0x1a34c</code> 分配。</li><li>我们跟踪带有虚假指针的页面。<ul><li>标记更新列表。</li><li>在那里分配最多小的无指针对象。</li></ul></li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="black-listing-contd">Black-listing (contd.)<a class="hash-link" href="#black-listing-contd" title="标题的直接链接">​</a></h2><ul><li>Can be substantial improvement, especially with large root sets containing
random, but static data.</li><li>Only dynamic data can cause retention.<ul><li>But dynamically created data is also more likely to disappear later.</li></ul></li><li><strong>Usually we see good results with conservative pointer finding, minimal layout information and</strong><ul><li><strong>32 bit address space, heaps up to a few 100MB, or</strong></li><li><strong>64-bit address space.</strong></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="黑名单-续">黑名单 (续)<a class="hash-link" href="#黑名单-续" title="标题的直接链接">​</a></h3><ul><li>可以大幅改进，尤其是对于包含随机但静态数据的大型根集。</li><li>只有动态数据会导致保留。<ul><li>但是动态创建的数据也更有可能在以后消失。</li></ul></li><li><strong>通常我们会通过保守的指针查找、最少的布局信息和</strong><ul><li><strong>32 位地址空间，最多可堆到 <code>100MB</code>，或</strong></li><li><strong>64 位地址空间。</strong></li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="optional-enhancements">Optional enhancements<a class="hash-link" href="#optional-enhancements" title="标题的直接链接">​</a></h2><ul><li>Remaining enhancements are (or were)
implemented and available, but not all combinable.</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="可选增强功能">可选增强功能<a class="hash-link" href="#可选增强功能" title="标题的直接链接">​</a></h3><ul><li>剩余的增强功能已（或曾经）实施并可用，但并非全部可组合。</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="generational-incremental-mostly-concurrent-gc">Generational, Incremental, Mostly Concurrent GC<a class="hash-link" href="#generational-incremental-mostly-concurrent-gc" title="标题的直接链接">​</a></h2><ul><li>Observation:<ul><li>Running marker concurrently establishes invariant:<ul><li>Pointers from marked objects or roots either<ul><li>point to marked objects, or</li><li>were modified since object was marked.</li></ul></li></ul></li><li>Such a concurrent mark phase can be fixed if we can<ul><li>Identify possibly modified objects (and roots)</li><li>Mark again from modified objects.</li></ul></li><li><strong>Most generational collectors track modifications with a compiler introduced &quot;write barrier&quot;.</strong> </li><li><strong>We use the VM system, e.g.</strong><ul><li><strong>Write protect pages (e.g. mprotect for Linux)</strong></li><li><strong>Catch protection faults (e.g. SIGSEGV)</strong></li></ul></li><li><strong>Free if allocation is rare, but otherwise not ideal.</strong></li></ul></li><li>Mostly concurrent GC:<ul><li>Run concurrent marker once.</li><li>Run fixup marker zero or more times concurrently, preserving invariant, reducing # dirty objects. </li><li>Run fixup marker with threads stopped once. </li><li>Works, reduces pause times, used in other systems. </li><li>Scheduling tricky, requires threads.</li></ul></li><li><strong>Incremental GC:</strong><ul><li><strong>Do a little &quot;concurrent&quot; marking during some allocations.</strong> </li><li><strong>Amount of marking proportional to allocation.</strong></li><li><strong>Same pause time benefit, no throughput benefit.</strong></li></ul></li><li><strong>Generational GC:</strong><ul><li><strong>Leave mark bits set after &quot;full GC&quot;, but track dirty pages.</strong> </li><li><strong>&quot;Fixup GC&quot; is minor GC.</strong></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="分代增量大部分并发">分代、增量、大部分并发<a class="hash-link" href="#分代增量大部分并发" title="标题的直接链接">​</a></h3><ul><li>观察：<ul><li>运行标记同时建立不变量：<ul><li>来自标记对象或根的指针<ul><li>指向标记的对象，或</li><li>自标记对象以来已修改。</li></ul></li></ul></li><li>如果可以的话，可以修复这样的并发标记阶段<ul><li>识别可能修改的对象（和根）</li><li>从修改的对象再次标记。</li></ul></li><li><strong>大多数世代收集器使用引入“写屏障”的编译器来跟踪修改。</strong></li><li><strong>我们使用VM系统，例如</strong><ul><li><strong>写保护页面（例如 <code>Linux</code> 的 <code>mprotect</code>）</strong></li><li><strong>捕获保护故障（例如 <code>SIGSEGV</code>）</strong></li></ul></li><li><strong>如果分配很少，则免费，否则不理想。</strong></li></ul></li><li>主要是并发<code>GC</code>：<ul><li>运行并发标记一次。</li><li>同时运行修正标记零次或多次，保持不变，减少#脏对象。</li><li>在线程停止一次的情况下运行修复标记。</li><li>工作，减少暂停时间，用于其他系统。</li><li>调度棘手，需要线程。</li></ul></li><li><strong>增量<code>GC</code>：</strong><ul><li><strong>在某些分配期间做一些“并发”标记。</strong></li><li><strong>标记量与分配成正比。</strong></li><li><strong>相同的暂停时间优势，没有吞吐量优势。</strong></li></ul></li><li><strong>分代<code>GC</code>：</strong><ul><li><strong>在<code>“full GC”</code>之后设置标记位，但跟踪脏页。</strong></li><li><strong><code>“Fixup GC”</code>是次要 <code>GC</code>。</strong></li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="parallel-marking--processor-scalability">Parallel marking &amp; processor scalability<a class="hash-link" href="#parallel-marking--processor-scalability" title="标题的直接链接">​</a></h2><ul><li>As client parallelism increases, eventually we spend all time in sequential
part of GC.</li><li>Sweeping is done a page at a time &amp; can be parallelized. What about marking?</li><li>Marking is also quite parallelizable.</li><li>First, and most thoroughly, done by Endo, Taura, and Yonezawa (SC97, 64 processor machine).</li><li>Our distribution contains simpler version ...</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="并行标记和处理器">并行标记和处理器<a class="hash-link" href="#并行标记和处理器" title="标题的直接链接">​</a></h3><ul><li>随着客户端并行度的增加，最终我们将所有时间都花在了 <code>GC</code> 的顺序部分。</li><li>扫描一次完成一页并且可以并行化。标记呢？</li><li>标记也是相当可并行的。</li><li>首先，也是最彻底的，由 <code>Endo</code>、<code>Taura</code> 和 <code>Yonezawa</code>（<code>SC97、64 processor machine</code>）完成。</li><li>我们的发行版包含更简单的版本...</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="parallel-marking">Parallel marking<a class="hash-link" href="#parallel-marking" title="标题的直接链接">​</a></h2><ul><li>For n processors, we have n-1 threads waiting to help with next GC.</li><li>Global mark stack becomes queue.</li><li>Each marker thread regularly:<ul><li>Removes a few entries from queue tail.</li><li>Marks from those using a local mark stack.</li></ul></li><li>Mark bits are shared between marker threads.<ul><li>Either use mark bytes, or atomic-compare-and-swap.<ul><li>Mark bytes usually win. (1/8 - 1/16 memory overhead.)</li></ul></li><li>Work may be duplicated but rarely is.</li></ul></li><li>Load balance by returning part of local stack to top of queue<ul><li>When local mark stack overflows.</li><li>When it notices empty global queue.</li></ul></li><li>Seems to scale adequately, at least for small SMPs.<ul><li>Limit appears to be bus bandwidth.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="并行标记">并行标记<a class="hash-link" href="#并行标记" title="标题的直接链接">​</a></h3><ul><li>对于 <code>n</code> 个处理器，我们有 <code>n-1</code> 个线程等待帮助下一次 <code>GC</code>。</li><li>全局标记栈变成队列。</li><li>每个标记线程定期：<ul><li>从队列尾部删除一些条目。</li><li>使用本地标记堆栈的标记。</li></ul></li><li>标记位在标记线程之间共享。<ul><li>要么使用标记字节，要么使用原子比较和交换。<ul><li>标记字节通常会获胜。（1/8 - 1/16 内存开销。）</li></ul></li><li>工作可能会重复，但很少会重复。</li></ul></li><li>通过将部分本地堆栈返回到队列顶部来进行负载平衡<ul><li>当本地标记堆栈溢出时。</li><li>当它注意到空的全局队列时。</li></ul></li><li>似乎可以充分扩展，至少对于小型 <code>SMP</code> 而言。<ul><li>限制似乎是总线带宽。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="parallel-marking-data-structure">Parallel marking data structure<a class="hash-link" href="#parallel-marking-data-structure" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200629.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="thread-local-allocation-buffers">Thread-local allocation buffers<a class="hash-link" href="#thread-local-allocation-buffers" title="标题的直接链接">​</a></h2><ul><li>Malloc/free implementations acquire and release a lock twice per object
allocation/deallocation:<ul><li>Once per allocation.</li><li>Once per deallocation.</li></ul></li><li>Garbage collectors avoid per-deallocation lock.</li><li>We can also avoid per-allocation lock!</li><li><strong>Use per-thread allocation caches.</strong><ul><li><strong>Each thread allocates a &quot;bunch&quot; of memory.</strong><ul><li><strong>Single lock acquisition.</strong> </li></ul></li><li><strong>Dividing it up doesn&#x27;t require a lock.</strong></li><li><strong>Easy with linear allocation, but also possible here.</strong></li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="线程局部分配">线程局部分配<a class="hash-link" href="#线程局部分配" title="标题的直接链接">​</a></h3><ul><li>Malloc/free 实现每次对象分配/释放两次获取和释放锁：<ul><li>每次分配一次。</li><li>每次释放一次。</li></ul></li><li>垃圾收集器避免每次释放锁。</li><li>我们还可以避免按分配锁！</li><li><strong>使用每线程分配缓存。</strong><ul><li><strong>每个线程分配一个“一堆”内存。</strong><ul><li><strong>单锁获取。</strong></li></ul></li><li><strong>分割它不需要锁。</strong></li><li><strong>线性分配很容易，但在这里也是可能的。</strong></li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="thread-local-allocation-details">Thread-local allocation details<a class="hash-link" href="#thread-local-allocation-details" title="标题的直接链接">​</a></h2><ul><li>Each thread has array of small object free-list headers.</li><li>Each header contains either:<ul><li>Count of allocated objects of that size.</li><li>Pointer to local free list.</li></ul></li><li>To allocate:<ul><li>For small counts, increment count, allocate from global free list.</li><li>For count at threshold, or empty free-list, get a page of objects.</li><li>For nonempty free-list, allocate from local free-list.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="线程局部分配细节">线程局部分配细节<a class="hash-link" href="#线程局部分配细节" title="标题的直接链接">​</a></h3><ul><li>每个线程都有一组小对象空闲列表头。</li><li>每个标头都包含：<ul><li>该大小的已分配对象的计数。</li><li>指向本地空闲列表的指针。</li></ul></li><li>分配：<ul><li>对于小计数，增加计数，从全局空闲列表中分配。</li><li>对于阈值计数或空空闲列表，获取对象页面。</li><li>对于非空空闲列表，从本地空闲列表中分配。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="finalization">Finalization<a class="hash-link" href="#finalization" title="标题的直接链接">​</a></h2><ul><li>Finalizable objects are added to a growable hash table.</li><li>After each GC, we walk this hash table two or three times:<ul><li>Mark all objects reachable from objects in the table.<ul><li>But not the objects in the table themselves.</li><li>Table entries contain the procedures to do this marking to handle variants
like Java.</li></ul></li><li>Enqueue still unmarked objects in the table for finalization, and possibly
mark them.</li><li>Possibly mark objects reachable from finalizable objects. (Java style
finalization only.)</li></ul></li><li>Process finalizable objects, preferably in separate thread, once allocation
lock is released. (See POPL 2003 paper.)</li><li>Weak pointers (&quot;disappearing links&quot;) are handled similarly.</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="终结">终结<a class="hash-link" href="#终结" title="标题的直接链接">​</a></h3><ul><li>可终结对象被添加到可增长的哈希表中。</li><li>每次 <code>GC</code> 之后，我们会遍历这个哈希表两到三遍：<ul><li>标记从表中的对象可到达的所有对象。<ul><li>但不是表中的对象本身。</li><li>表条目包含执行此标记以处理 <code>Java</code> 等变体的过程。</li></ul></li><li>将表中仍未标记的对象排入队列以进行最终确定，并可能标记它们。</li><li>可能标记可从可终结对象到达的对象。（仅限 <code>Java</code> 风格的最终确定。）</li></ul></li><li>一旦分配锁被释放，最好在单独的线程中处理可终结的对象。（参见 <code>POPL 2003</code> 论文。）</li><li>弱指针（“消失的链接”）的处理方式类似。</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="finalization-quick-observations">Finalization (quick observations)<a class="hash-link" href="#finalization-quick-observations" title="标题的直接链接">​</a></h2><ul><li>Finalization is moderately expensive.<ul><li>Extra space overhead.</li><li>Tracing cost is significantly higher, even with Java-style finalization
(factor of 5?)</li></ul></li><li>Clients should avoid registering unnecessary finalizers.
(JVMs can do this statically.)</li><li>Finalizers do not affect performance of the rest of the GC.</li><li>Finalizers must introduce concurrency (even if we had a simple reference
counting collector). There is no such thing as deterministic finalization for
heap objects.<ul><li>Collector runs them in GC_malloc by default. This is a bug except in very
simple cases. Use GC_finalizer_notifier.</li><li>Concurrency is tricky. Be careful.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="终结快速观察">终结(快速观察)<a class="hash-link" href="#终结快速观察" title="标题的直接链接">​</a></h3><ul><li>最终确定的成本适中。<ul><li>额外的空间开销。</li><li>跟踪成本明显更高，即使使用 <code>Java</code> 风格的终结（5 倍？）</li></ul></li><li>客户端应避免注册不必要的终结器。（<code>JVM</code> 可以静态地执行此操作。）</li><li>终结器不会影响 <code>GC</code> 其余部分的性能。</li><li>终结器必须引入并发性（即使我们有一个简单的引用计数收集器）。堆对象没有确定性终结之类的东西。<ul><li>收集器默认在 <code>GC_malloc</code> 中运行它们。除了非常简单的情况外，这是一个错误。使用 <code>GC_finalizer_notifier</code>。</li><li>并发是棘手的。当心。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="debugging-support">Debugging support<a class="hash-link" href="#debugging-support" title="标题的直接链接">​</a></h2><ul><li><p>Debug allocators &quot;wrap&quot; each object with extra information:</p><ul><li>Source file, line number of allocation site.</li><li>Possibly a stack trace for allocation site.</li><li>Space for a back pointer. (Should be elsewhere...)</li><li>Requested object size.</li><li>Magic (address dependent) numbers before and after object.</li></ul></li><li><p>Can mostly tolerate a mixture of wrapped and unwrapped objects.</p><ul><li>Relies on &quot;magic numbers&quot;.</li><li>May lead to extra error reports.</li></ul></li><li><p>调试分配器用额外的信息“包装”每个对象：</p><ul><li>源文件，分配站点的行号。</li><li>可能是分配站点的堆栈跟踪。</li><li>后向指针的空间。（应该在别处……）</li><li>请求的对象大小。</li><li>对象前后的魔术（地址相关）数字。</li></ul></li><li><p>大多数情况下可以容忍包裹和未包裹物体的混合。</p><ul><li>依靠“幻数”。</li><li>可能导致额外的错误报告。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="debugging-facilities">Debugging facilities<a class="hash-link" href="#debugging-facilities" title="标题的直接链接">​</a></h2><ul><li>GC can check for overwrite errors.</li><li>Various error checks in GC_debug routines.</li><li>Can be configured for leak detection.</li><li>Can tell you whether a single misidentified pointer might result in unbounded
space leak (See POPL 2002)</li><li>Can give back-traces of random heap samples (requires different build flags):<div class="codeBlockContainer_CBWl language-log theme-code-block"><div class="codeBlockContent_vhl8" style="color:#393A34;background-color:#f6f8fa"><pre tabindex="0" class="prism-code language-log codeBlock_w2AC thin-scrollbar"><code class="codeBlockLines_OfWd"><span class="token-line" style="color:#393A34"><span class="token plain">  ****Chose address 0x81ac567 in object 0x81ac568 (trace_test.c:13, sz=8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  PTRFREE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Reachable via 0 levels of pointers from offset 4 in object:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  0x8192090 (trace_test.c:11, sz=8, NORMAL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Reachable via 1 levels of pointers from offset 0 in object:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  0x81920b8 (trace_test.c:11, sz=8, NORMAL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Reachable via 2 levels of pointers from root at 0x8055bd4</span><br></span></code></pre><button type="button" aria-label="复制代码到剪贴板" title="复制" class="copyButton_R7VQ clean-btn"><span class="copyButtonIcons_Uqyx" aria-hidden="true"><svg class="copyButtonIcon_CtfL" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_Mq1p" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="调试设施">调试设施<a class="hash-link" href="#调试设施" title="标题的直接链接">​</a></h3><ul><li><code>GC</code> 可以检查覆盖错误。</li><li><code>GC_debug</code> 例程中的各种错误检查。</li><li>可配置用于泄漏检测。</li><li>可以告诉您单个错误识别的指针是否可能导致无限空间泄漏（参见 <code>POPL 2002</code>）</li><li>可以提供随机堆样本的回溯（需要不同的构建标志）：</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="current-state">Current state<a class="hash-link" href="#current-state" title="标题的直接链接">​</a></h2><ul><li>Easily available (google &quot;garbage collector&quot;)</li><li>Supports Linux, Unix variants, Windows, MacOSX,</li><li>Used in a variety of C/C++ systems<ul><li>w3m, vesta, ...</li><li>High end Xerox printers.</li><li>Sometimes as leak detector (e.g Mozilla).</li><li>Usually with little type information.</li></ul></li><li>Used in many language runtimes:<ul><li>Gcj (gcc), Mono, Bigloo Scheme</li><li>Usually with heap type information.</li><li>Information on static data (e.g. 4.5MB for gcj) would be easy and useful.</li></ul></li><li><strong>Current version 6.3; 6.4 should appear shortly.</strong></li><li><strong>Stay tuned for 7.0alpha1 (cleaner code base, ...)</strong></li></ul><ul><li>容易获得（百度一下“垃圾收集器”）</li><li>支持 <code>Linux</code>、<code>Unix</code> 变体、<code>Windows</code>、<code>MacOSX</code>、</li><li>用于各种 <code>C/C++</code> 系统<ul><li><code>w3m</code>, <code>vesta</code>, ...</li><li>高端施乐打印机。</li><li>有时用作检漏仪（例如 <code>Mozilla</code>）。</li><li>通常只有很少的类型信息。</li></ul></li><li>在许多语言运行时中使用：<ul><li><code>Gcj (gcc)</code>、<code>Mono</code>、<code>Bigloo</code> 方案</li><li>通常带有堆类型信息。</li><li>有关静态数据的信息（例如，<code>gcj</code> 为 <code>4.5MB</code>）将是简单而有用的。</li></ul></li><li><strong>当前版本 <code>6.3</code>；<code>6.4</code> 应该很快就会出现。</strong></li><li><strong>请继续关注 <code>7.0alpha1</code>（更简洁的代码库，...）</strong></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="performance-characteristics">Performance characteristics<a class="hash-link" href="#performance-characteristics" title="标题的直接链接">​</a></h2><ul><li>We use GCBench here.<ul><li>More of a sanity check than a benchmark. </li><li>Allocates complete binary trees of varying depths.</li><li>Depth n -&gt; 2 n - 1 nodes of 2 pointers + 2 ints</li><li>Translated to multiple source languages.</li><li>Can see effect of object lifetime. </li><li>About as realistic as any toy benchmark (not very)</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="性能特点">性能特点<a class="hash-link" href="#性能特点" title="标题的直接链接">​</a></h3><ul><li>我们在这里使用 <code>GCBench</code>。<ul><li>与其说是基准，不如说是健全性检查。</li><li>分配不同深度的完整二叉树。</li><li>深度 n -&gt; 2 n - 2 个指针的 1 个节点 + 2 个整数</li><li>翻译成多种源语言。</li><li>可以看到对象生命周期的影响。</li><li>与任何玩具基准一样逼真（不是非常）</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="gcbench-vs-hotspot-142-client">GCBench vs HotSpot 1.4.2 client<a class="hash-link" href="#gcbench-vs-hotspot-142-client" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200803.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="cc-gcbench-comparison">C/C++ GCBench Comparison<a class="hash-link" href="#cc-gcbench-comparison" title="标题的直接链接">​</a></h2><ul><li>Compare:<ul><li>C with malloc/free<ul><li>&quot;Pause&quot; is tree deallocation time (predictable).</li></ul></li><li>Boost classic reference counting (simple and tuned version)<ul><li>&quot;Pause&quot; is recursive deallocation time during assignment(unpredictable).</li></ul></li><li>Boost versions use C++ benchmark.</li><li>Expl. free and BDW GC use C version.</li><li>HotSpot uses Java version.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="cc-gcbench-比较">C/C++ <code>GCBench</code> 比较<a class="hash-link" href="#cc-gcbench-比较" title="标题的直接链接">​</a></h3><ul><li>比较：<ul><li><code>C</code> 带 <code>malloc/free</code><ul><li>“暂停”是树释放时间（可预测）。</li></ul></li><li>提升经典引用计数（简单和调整的版本）<ul><li>“暂停”是分配期间的递归释放时间（不可预测）。</li></ul></li><li><code>Boost</code> 版本使用 <code>C++</code> 基准测试。</li><li>解释。<code>free</code> 和 <code>BDW GC</code> 使用 <code>C</code> 版本。</li><li><code>HotSpot</code> 使用 <code>Java</code> 版本。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="execution-time-msecs-2ghz-xeon-vs-alternatives">Execution time (msecs, 2GHz Xeon) vs. alternatives<a class="hash-link" href="#execution-time-msecs-2ghz-xeon-vs-alternatives" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200836.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="max-space-usage-mb-vs-others">Max. space usage (MB) vs. others<a class="hash-link" href="#max-space-usage-mb-vs-others" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200856.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="max-pause-time-msecs-vs-others">Max pause time (msecs) vs. others<a class="hash-link" href="#max-pause-time-msecs-vs-others" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200917.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="but">But:<a class="hash-link" href="#but" title="标题的直接链接">​</a></h2><ul><li>GCBench uses small objects.</li><li>Allocation + GC cost is proportional to object size.</li><li><strong>Redo experiment with 128 extra null pointer per node.</strong></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="但是">但是<a class="hash-link" href="#但是" title="标题的直接链接">​</a></h3><ul><li><code>GCBench</code> 使用小对象。</li><li>分配 + <code>GC</code> 成本与对象大小成正比。</li><li><strong>重做实验，每个节点有 128 个额外的空指针。</strong></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="large-objectsmsecs-mb-2ghz-xeon">Large objects(msecs, MB, 2GHz Xeon)<a class="hash-link" href="#large-objectsmsecs-mb-2ghz-xeon" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409200955.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="large-objectsthread-safe">Large objects(thread-safe)<a class="hash-link" href="#large-objectsthread-safe" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409201050.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="some-older-measurements-on-malloc-benchmarks">Some older measurements on malloc benchmarks<a class="hash-link" href="#some-older-measurements-on-malloc-benchmarks" title="标题的直接链接">​</a></h2><ul><li>These are a bit obsolete, things have probably improved, but ...</li><li>Measured on 4xPPro (which was obsolete then).</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="malloc基准上的一些旧测量"><code>malloc</code>基准上的一些旧测量<a class="hash-link" href="#malloc基准上的一些旧测量" title="标题的直接链接">​</a></h3><ul><li>这些有点过时了，情况可能有所改善，但是...</li><li>在 <code>4xPPro</code>（当时已经过时）上测量。</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="ghostscript-throughput">Ghostscript throughput<a class="hash-link" href="#ghostscript-throughput" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409201114.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="mt_gcbench2-throughput">MT_GCBench2 throughput<a class="hash-link" href="#mt_gcbench2-throughput" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409201152.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="larson-slightly-mod-benchmark-throughput">Larson (slightly mod.) benchmark throughput<a class="hash-link" href="#larson-slightly-mod-benchmark-throughput" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409201215.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="larson-small-throughput">Larson-small throughput<a class="hash-link" href="#larson-small-throughput" title="标题的直接链接">​</a></h2><p><img loading="lazy" src="https://raw.githubusercontent.com/danyow/picgo/main/20220409201301.png" class="img_PFMr"></p><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="other-experiences">Other experiences<a class="hash-link" href="#other-experiences" title="标题的直接链接">​</a></h2><ul><li>Generally works quite well for small (&lt; 100MB live data)
clients or on 64-bit machines.<ul><li>Sometimes needs a bit pointer location information for frequently occurring
heap objects. Usually GC_MALLOC_ATOMIC is sufficient for C code.</li></ul></li><li>Some successful uses with much larger heaps.</li><li>Some problems with 500MB heaps on 32-bit machines.</li><li>Large arrays (&gt; about 1MB) sometimes problematic.</li><li>Fragmentation cost (for heaps &gt; a few MB) is typically less than a factor of
2.<ul><li>Fragmentation essentially never an issue for small objects.</li><li>Whole block coalescing is important.</li></ul></li><li>I haven&#x27;t seen much of a problem with long running apps.
(Vesta, Xerox printers).</li><li>Stationary objects allow one word object headers in gcj.</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="其他经验">其他经验<a class="hash-link" href="#其他经验" title="标题的直接链接">​</a></h3><ul><li>通常适用于小型（&lt; <code>100MB</code> 实时数据）客户端或 64 位机器。<ul><li>有时需要频繁出现的堆对象的位指针位置信息。通常 <code>GC_MALLOC_ATOMIC</code> 对于 C 代码就足够了。</li></ul></li><li>一些成功的使用更大的堆。</li><li>32 位机器上 <code>500MB</code> 堆的一些问题。</li><li>大型数组（&gt; 大约 <code>1MB</code>）有时会出现问题。</li><li>碎片成本（对于 &gt; 几 <code>MB</code> 的堆）通常小于 2 倍。<ul><li>对于小物体来说，碎片化基本上不是问题。</li><li>整个块合并很重要。</li></ul></li><li>我没有看到长时间运行的应用程序有什么问题。（<code>Vesta</code>，<code>Xerox printers</code>）。</li><li>固定对象允许在 <code>gcj</code> 中使用一个单词对象标题。</li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="space-overhead-of-conservative-gc">Space overhead of conservative GC<a class="hash-link" href="#space-overhead-of-conservative-gc" title="标题的直接链接">​</a></h2><ul><li>Clever empirical study:<ul><li>Hirzel, Diwan, Henkel, &quot;On the Usefulness of Type and Liveness Accuracy for
Garbage Collection&quot;, TOPLAS 24, 6, November 2002.<ul><li>Liveness information is usually more important than type information,
especially on 64-bit platforms.</li><li>Up to 62% space overhead.</li></ul></li></ul></li><li>More theoretical study:<ul><li>Boehm, &quot;Bounding Space Usage of Conservative Garbage Collectors&quot;, POPL 2002.</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="保守gc的空间开销">保守<code>GC</code>的空间开销<a class="hash-link" href="#保守gc的空间开销" title="标题的直接链接">​</a></h3><ul><li>巧妙的实证研究：<ul><li><code>Hirzel</code>, <code>Diwan</code>, <code>Henkel</code>，“关于垃圾收集的类型和活性准确性的有用性”，<code>TOPLAS 24, 6, November 2002</code>。<ul><li>活性信息通常比类型信息更重要，尤其是在 64 位平台上。</li><li>高达 62% 的空间开销。</li></ul></li></ul></li><li>更多理论研究：<ul><li><code>Boehm</code>，“保守垃圾收集器的边界空间使用”，<code>POPL 2002</code>。</li></ul></li></ul><hr><h2 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="conclusions">Conclusions<a class="hash-link" href="#conclusions" title="标题的直接链接">​</a></h2><ul><li>Collector is still a useful tool for<ul><li>Avoiding manual memory management issues in C/C++.</li><li>Quickly building language runtimes, especially, but not only, for research
systems.</li><li>Some GC research. (One underlying algorithm, mult. languages.)</li></ul></li><li>Performance is competitive with malloc/free.<ul><li>Usually wins for threads + small objects.</li></ul></li><li>Tracing performance is very close to best commercial JVMs.<ul><li>See also Smith and Morrisett, ISMM 98.</li><li>Currently does less well when there is a large benefit from generational
GC. (But see OOPSLA 2003 paper by Barabash et al.)</li></ul></li><li>There may be a cache cost to free list allocation.<ul><li>See work by Blackburn, Cheng, and McKinley.</li><li>But I don&#x27;t think we fully understand this yet...</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_c5FC" id="结论">结论<a class="hash-link" href="#结论" title="标题的直接链接">​</a></h3><ul><li>收集器仍然是一个有用的工具<ul><li>避免 <code>C/C++</code> 中的手动内存管理问题。</li><li>快速构建语言运行时，尤其是但不仅限于研究系统。</li><li>一些 <code>GC</code> 研究。（一种底层算法，多种语言。）</li></ul></li><li>性能与 <code>malloc/free</code> 具有竞争力。<ul><li>通常赢得线程+小对象。</li></ul></li><li>跟踪性能非常接近最好的商业 <code>JVM</code>。<ul><li>另见 <code>Smith</code> 和 <code>Morrisett，ISMM 98</code>。</li><li>当分代 <code>GC</code> 有很大的好处时，目前做得不太好。（但请参阅 <code>Barabash</code> 等人的 <code>OOPSLA 2003</code> 论文。）</li></ul></li><li>空闲列表分配可能会产生缓存成本。<ul><li>参见 <code>Blackburn</code>、<code>Cheng</code> 和 <code>McKinley</code> 的作品。</li><li>但我认为我们还没有完全理解这一点......</li></ul></li></ul><hr></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://crowdin.com/project/docusaurus-v2/zh-Hans" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_OMbO" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vA0S"><span class="theme-last-updated">最后<!-- -->由 <b>danyow</b> <!-- -->于 <b><time datetime="2022-04-10T02:13:31.000Z">2022/4/10</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/translation"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">翻译</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/translation/luagc"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Lua的垃圾回收</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_jWtb thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#outline" class="table-of-contents__link toc-highlight">Outline</a><ul><li><a href="#概述" class="table-of-contents__link toc-highlight">概述</a></li></ul></li><li><a href="#what-is-it" class="table-of-contents__link toc-highlight">What is it?</a><ul><li><a href="#他是什么" class="table-of-contents__link toc-highlight">他是什么？</a></li></ul></li><li><a href="#example-lisp-s-expressions" class="table-of-contents__link toc-highlight">Example: Lisp S-expressions</a><ul><li><a href="#示例lisp-s-expressions" class="table-of-contents__link toc-highlight">示例：<code>Lisp S-expressions</code></a></li></ul></li><li><a href="#where-did-it-come-from" class="table-of-contents__link toc-highlight">Where did it come from?</a><ul><li><a href="#它是从哪里来的" class="table-of-contents__link toc-highlight">它是从哪里来的？</a></li></ul></li><li><a href="#what-else-can-it-do" class="table-of-contents__link toc-highlight">What else can it do?</a><ul><li><a href="#它还能做什么" class="table-of-contents__link toc-highlight">它还能做什么？</a></li></ul></li><li><a href="#what-cant-it-do" class="table-of-contents__link toc-highlight">What can&#39;t it do?</a><ul><li><a href="#它不能做什么" class="table-of-contents__link toc-highlight">它不能做什么?</a></li></ul></li><li><a href="#dealing-with-c-conservative-garbage-collection" class="table-of-contents__link toc-highlight">Dealing with C: Conservative Garbage Collection</a><ul><li><a href="#与c打交道保守的垃圾收集" class="table-of-contents__link toc-highlight">与<code>C</code>打交道：保守的垃圾收集</a></li></ul></li><li><a href="#c-interface-overview" class="table-of-contents__link toc-highlight">C Interface overview</a><ul><li><a href="#c接口概述" class="table-of-contents__link toc-highlight"><code>C</code>接口概述</a></li></ul></li><li><a href="#c-interface-main-functions" class="table-of-contents__link toc-highlight">C interface, main functions</a><ul><li><a href="#c-接口-主要的一些方法" class="table-of-contents__link toc-highlight"><code>C</code> 接口, 主要的一些方法:</a></li></ul></li><li><a href="#c-interface" class="table-of-contents__link toc-highlight">C++ interface</a><ul><li><a href="#c接口" class="table-of-contents__link toc-highlight"><code>C++</code>接口</a></li></ul></li><li><a href="#environment-variables" class="table-of-contents__link toc-highlight">Environment variables</a><ul><li><a href="#环境变量" class="table-of-contents__link toc-highlight">环境变量</a></li></ul></li><li><a href="#how-does-it-work" class="table-of-contents__link toc-highlight">How does it work?</a><ul><li><a href="#它是如何工作的" class="table-of-contents__link toc-highlight">它是如何工作的？</a></li></ul></li><li><a href="#marksweep-illustration" class="table-of-contents__link toc-highlight">Mark/sweep illustration</a><ul><li><a href="#标记清除-插画" class="table-of-contents__link toc-highlight">标记/清除 插画</a></li></ul></li><li><a href="#easy-performance-issue" class="table-of-contents__link toc-highlight">Easy performance issue</a><ul><li><a href="#简单性能问题" class="table-of-contents__link toc-highlight">简单性能问题</a></li></ul></li><li><a href="#asymptotic-complexity-of-marksweep-vs-copying" class="table-of-contents__link toc-highlight">Asymptotic Complexity of MarkSweep vs. Copying</a><ul><li><a href="#运行时间复杂度-ms-vs-copying分析" class="table-of-contents__link toc-highlight">运行时间复杂度 <code>M&amp;S</code> vs <code>Copying</code>分析.</a></li></ul></li><li><a href="#implementation-details-overview" class="table-of-contents__link toc-highlight">Implementation details overview</a><ul><li><a href="#实现细节描述" class="table-of-contents__link toc-highlight">实现细节描述</a></li></ul></li><li><a href="#allocator-design" class="table-of-contents__link toc-highlight">Allocator design</a><ul><li><a href="#分配器设计" class="table-of-contents__link toc-highlight">分配器设计</a></li></ul></li><li><a href="#heap-layout" class="table-of-contents__link toc-highlight">Heap layout</a><ul><li><a href="#堆布局" class="table-of-contents__link toc-highlight">堆布局</a></li></ul></li><li><a href="#meta-data" class="table-of-contents__link toc-highlight">Meta-data</a><ul><li><a href="#元数据" class="table-of-contents__link toc-highlight">元数据</a></li></ul></li><li><a href="#meta-data-lookup" class="table-of-contents__link toc-highlight">Meta-data lookup</a></li><li><a href="#pointer-validity-check" class="table-of-contents__link toc-highlight">Pointer validity check</a><ul><li><a href="#指针有效性检查" class="table-of-contents__link toc-highlight">指针有效性检查</a></li></ul></li><li><a href="#partial-pointer-location-type-information" class="table-of-contents__link toc-highlight">Partial pointer location (type) information.</a><ul><li><a href="#部分指针位置类型信息" class="table-of-contents__link toc-highlight">部分指针位置（类型）信息。</a></li></ul></li><li><a href="#locating-roots" class="table-of-contents__link toc-highlight">Locating roots</a><ul><li><a href="#定位根" class="table-of-contents__link toc-highlight">定位根</a></li></ul></li><li><a href="#basic-mark-algorithm" class="table-of-contents__link toc-highlight">Basic mark algorithm</a><ul><li><a href="#基本标记算法" class="table-of-contents__link toc-highlight">基本标记算法</a></li></ul></li><li><a href="#marker-refinements" class="table-of-contents__link toc-highlight">Marker refinements</a><ul><li><a href="#标记改进" class="table-of-contents__link toc-highlight">标记改进</a></li></ul></li><li><a href="#the-marker-core-version-pre-70" class="table-of-contents__link toc-highlight">The marker core (version pre-7.0)</a><ul><li><a href="#标记器核心70之前的版本" class="table-of-contents__link toc-highlight">标记器核心（7.0之前的版本）</a></li></ul></li><li><a href="#marker-performance-why-gc-needs-a-fast-multiplier" class="table-of-contents__link toc-highlight">Marker performance: Why GC needs a fast multiplier.</a><ul><li><a href="#标记器性能为什么-gc-需要快速乘法器" class="table-of-contents__link toc-highlight">标记器性能：为什么 <code>GC</code> 需要快速乘法器</a></li></ul></li><li><a href="#what-if-the-mark-stack-overflows" class="table-of-contents__link toc-highlight">What if the mark stack overflows?</a><ul><li><a href="#如果标记堆栈溢出" class="table-of-contents__link toc-highlight">如果标记堆栈溢出</a></li></ul></li><li><a href="#the-sweep-phase" class="table-of-contents__link toc-highlight">The &quot;sweep phase&quot;</a><ul><li><a href="#清除阶段" class="table-of-contents__link toc-highlight">清除阶段</a></li></ul></li><li><a href="#thread-support" class="table-of-contents__link toc-highlight">Thread support</a><ul><li><a href="#线程支持" class="table-of-contents__link toc-highlight">线程支持</a></li></ul></li><li><a href="#enhancement-1-black-listing" class="table-of-contents__link toc-highlight">Enhancement 1: Black-listing</a></li><li><a href="#black-listing-contd" class="table-of-contents__link toc-highlight">Black-listing (contd.)</a><ul><li><a href="#黑名单-续" class="table-of-contents__link toc-highlight">黑名单 (续)</a></li></ul></li><li><a href="#optional-enhancements" class="table-of-contents__link toc-highlight">Optional enhancements</a><ul><li><a href="#可选增强功能" class="table-of-contents__link toc-highlight">可选增强功能</a></li></ul></li><li><a href="#generational-incremental-mostly-concurrent-gc" class="table-of-contents__link toc-highlight">Generational, Incremental, Mostly Concurrent GC</a><ul><li><a href="#分代增量大部分并发" class="table-of-contents__link toc-highlight">分代、增量、大部分并发</a></li></ul></li><li><a href="#parallel-marking--processor-scalability" class="table-of-contents__link toc-highlight">Parallel marking &amp; processor scalability</a><ul><li><a href="#并行标记和处理器" class="table-of-contents__link toc-highlight">并行标记和处理器</a></li></ul></li><li><a href="#parallel-marking" class="table-of-contents__link toc-highlight">Parallel marking</a><ul><li><a href="#并行标记" class="table-of-contents__link toc-highlight">并行标记</a></li></ul></li><li><a href="#parallel-marking-data-structure" class="table-of-contents__link toc-highlight">Parallel marking data structure</a></li><li><a href="#thread-local-allocation-buffers" class="table-of-contents__link toc-highlight">Thread-local allocation buffers</a><ul><li><a href="#线程局部分配" class="table-of-contents__link toc-highlight">线程局部分配</a></li></ul></li><li><a href="#thread-local-allocation-details" class="table-of-contents__link toc-highlight">Thread-local allocation details</a><ul><li><a href="#线程局部分配细节" class="table-of-contents__link toc-highlight">线程局部分配细节</a></li></ul></li><li><a href="#finalization" class="table-of-contents__link toc-highlight">Finalization</a><ul><li><a href="#终结" class="table-of-contents__link toc-highlight">终结</a></li></ul></li><li><a href="#finalization-quick-observations" class="table-of-contents__link toc-highlight">Finalization (quick observations)</a><ul><li><a href="#终结快速观察" class="table-of-contents__link toc-highlight">终结(快速观察)</a></li></ul></li><li><a href="#debugging-support" class="table-of-contents__link toc-highlight">Debugging support</a></li><li><a href="#debugging-facilities" class="table-of-contents__link toc-highlight">Debugging facilities</a><ul><li><a href="#调试设施" class="table-of-contents__link toc-highlight">调试设施</a></li></ul></li><li><a href="#current-state" class="table-of-contents__link toc-highlight">Current state</a></li><li><a href="#performance-characteristics" class="table-of-contents__link toc-highlight">Performance characteristics</a><ul><li><a href="#性能特点" class="table-of-contents__link toc-highlight">性能特点</a></li></ul></li><li><a href="#gcbench-vs-hotspot-142-client" class="table-of-contents__link toc-highlight">GCBench vs HotSpot 1.4.2 client</a></li><li><a href="#cc-gcbench-comparison" class="table-of-contents__link toc-highlight">C/C++ GCBench Comparison</a><ul><li><a href="#cc-gcbench-比较" class="table-of-contents__link toc-highlight">C/C++ <code>GCBench</code> 比较</a></li></ul></li><li><a href="#execution-time-msecs-2ghz-xeon-vs-alternatives" class="table-of-contents__link toc-highlight">Execution time (msecs, 2GHz Xeon) vs. alternatives</a></li><li><a href="#max-space-usage-mb-vs-others" class="table-of-contents__link toc-highlight">Max. space usage (MB) vs. others</a></li><li><a href="#max-pause-time-msecs-vs-others" class="table-of-contents__link toc-highlight">Max pause time (msecs) vs. others</a></li><li><a href="#but" class="table-of-contents__link toc-highlight">But:</a><ul><li><a href="#但是" class="table-of-contents__link toc-highlight">但是</a></li></ul></li><li><a href="#large-objectsmsecs-mb-2ghz-xeon" class="table-of-contents__link toc-highlight">Large objects(msecs, MB, 2GHz Xeon)</a></li><li><a href="#large-objectsthread-safe" class="table-of-contents__link toc-highlight">Large objects(thread-safe)</a></li><li><a href="#some-older-measurements-on-malloc-benchmarks" class="table-of-contents__link toc-highlight">Some older measurements on malloc benchmarks</a><ul><li><a href="#malloc基准上的一些旧测量" class="table-of-contents__link toc-highlight"><code>malloc</code>基准上的一些旧测量</a></li></ul></li><li><a href="#ghostscript-throughput" class="table-of-contents__link toc-highlight">Ghostscript throughput</a></li><li><a href="#mt_gcbench2-throughput" class="table-of-contents__link toc-highlight">MT_GCBench2 throughput</a></li><li><a href="#larson-slightly-mod-benchmark-throughput" class="table-of-contents__link toc-highlight">Larson (slightly mod.) benchmark throughput</a></li><li><a href="#larson-small-throughput" class="table-of-contents__link toc-highlight">Larson-small throughput</a></li><li><a href="#other-experiences" class="table-of-contents__link toc-highlight">Other experiences</a><ul><li><a href="#其他经验" class="table-of-contents__link toc-highlight">其他经验</a></li></ul></li><li><a href="#space-overhead-of-conservative-gc" class="table-of-contents__link toc-highlight">Space overhead of conservative GC</a><ul><li><a href="#保守gc的空间开销" class="table-of-contents__link toc-highlight">保守<code>GC</code>的空间开销</a></li></ul></li><li><a href="#conclusions" class="table-of-contents__link toc-highlight">Conclusions</a><ul><li><a href="#结论" class="table-of-contents__link toc-highlight">结论</a></li></ul></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.143b31b0.js"></script>
<script src="/assets/js/main.cabcfe72.js"></script>
</body>
</html>